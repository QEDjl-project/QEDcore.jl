var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QEDcore","category":"page"},{"location":"#QEDcore","page":"Home","title":"QEDcore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QEDcore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QEDcore]","category":"page"},{"location":"#QEDcore.AdjointBiSpinor","page":"Home","title":"QEDcore.AdjointBiSpinor","text":"struct AdjointBiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model an adjoint Dirac four-spinor with complex-valued components. These are the elements of the dual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AntiBoson","page":"Home","title":"QEDcore.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AntiFermion","page":"Home","title":"QEDcore.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion haveis_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BiSpinor","page":"Home","title":"QEDcore.BiSpinor","text":"struct BiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model a Dirac four-spinor with complex-valued components. These are the elements of an actual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Boson","page":"Home","title":"QEDcore.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BosonLike","page":"Home","title":"QEDcore.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.CenterOfMomentumFrame","page":"Home","title":"QEDcore.CenterOfMomentumFrame","text":"CenterOfMomentumFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.DiracMatrix","page":"Home","title":"QEDcore.DiracMatrix","text":"struct DiracMatrix <: AbstractDiracMatrix{ComplexF64}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Electron","page":"Home","title":"QEDcore.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Electron()\nelectron\n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Electron) = 1.0\ncharge(::Electron) = -1.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.ElectronRestFrame","page":"Home","title":"QEDcore.ElectronRestFrame","text":"ElectronRestFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Fermion","page":"Home","title":"QEDcore.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.FermionLike","page":"Home","title":"QEDcore.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.InPhaseSpacePoint","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: OutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}}} where {N, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_momenta::NTuple{N,AbstractFourMomentum},\n)\n\nConstruct a PhaseSpacePoint with only input particles from given momenta. The result will be <: InPhaseSpacePoint but not <: OutPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{IN_PARTICLES}, Tuple{PSDEF}, Tuple{MODEL}, Tuple{PROC}, Tuple{PROC, MODEL, PSDEF, IN_PARTICLES}} where {PROC<:AbstractProcessDefinition, MODEL<:AbstractModelDefinition, PSDEF<:AbstractPhasespaceDefinition, IN_PARTICLES<:Tuple{Vararg{ParticleStateful}}}","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition, \n    model::AbstractModelDefinition, \n    ps_def::AbstractPhasespaceDefinition, \n    in_ps::Tuple{ParticleStateful},\n)\n\nConstruct a [`PhaseSpacePoint`](@ref) with only input particles from [`ParticleStateful`](@ref)s. The result will be `<: InPhaseSpacePoint` but **not** `<: OutPhaseSpacePoint`.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{Real, N}}}} where N","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_coords::NTuple{N,Real},\n)\n\nConstruct a PhaseSpacePoint from given coordinates by using the _generate_momenta interface. The result will be <: InPhaseSpacePoint but not <: OutPhaseSpacePoint.\n\nnote: Note\nA similar function for OutPhaseSpacePoint does not exist from coordinates, only a full PhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.MFourMomentum","page":"Home","title":"QEDcore.MFourMomentum","text":"mutable struct MFourMomentum <: AbstractFourMomentum\n\nBuilds a mutable LorentzVector with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"Home","title":"QEDcore.MFourMomentum","text":"MFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nMFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> MFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.MLorentzVector","page":"Home","title":"QEDcore.MLorentzVector","text":"mutable struct MLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic mutable Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MajoranaBoson","page":"Home","title":"QEDcore.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson haveis_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MajoranaFermion","page":"Home","title":"QEDcore.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion haveis_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.OutPhaseSpacePoint","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: InPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.OutPhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}}} where {N, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    out_momenta::NTuple{N,AbstractFourMomentum},\n)\n\nConstruct a PhaseSpacePoint with only output particles from given momenta. The result will be <: OutPhaseSpacePoint but not <: InPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.OutPhaseSpacePoint-Union{Tuple{OUT_PARTICLES}, Tuple{PSDEF}, Tuple{MODEL}, Tuple{PROC}, Tuple{PROC, MODEL, PSDEF, OUT_PARTICLES}} where {PROC<:AbstractProcessDefinition, MODEL<:AbstractModelDefinition, PSDEF<:AbstractPhasespaceDefinition, OUT_PARTICLES<:Tuple{Vararg{ParticleStateful}}}","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint(\n    proc::AbstractProcessDefinition, \n    model::AbstractModelDefinition, \n    ps_def::AbstractPhasespaceDefinition, \n    out_ps::Tuple{ParticleStateful},\n)\n\nConstruct a PhaseSpacePoint with only output particles from ParticleStatefuls. The result will be <: OutPhaseSpacePoint but not <: InPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.ParticleStateful","page":"Home","title":"QEDcore.ParticleStateful","text":"ParticleStateful <: AbstractParticle\n\nRepresentation of a particle with a state. It has four fields:\n\ndir::ParticleDirection: The direction of the particle, Incoming() or Outgoing().\nspecies::AbstractParticleType: The species of the particle, Electron(), Positron() etc.\nmom::AbstractFourMomentum: The momentum of the particle.\n\nOverloads for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are provided, delegating the call to the correct field and thus implementing the AbstractParticle interface.\n\njulia> using QEDcore\n\njulia> ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: incoming electron\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\njulia> ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: outgoing photon\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.ParticleStateful-Union{Tuple{AbstractFourMomentum}, Tuple{SPECIES}, Tuple{DIR}} where {DIR<:ParticleDirection, SPECIES<:AbstractParticleType}","page":"Home","title":"QEDcore.ParticleStateful","text":"ParticleStateful{DIR, SPECIES}(mom::AbstractFourMomentum)\nParticleStateful{DIR, SPECIES, EL}(mom::EL)\n\nConstruct a ParticleStateful from the given momentum on a fully or partially specified type.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhaseSpacePoint","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint\n\nRepresentation of a point in the phase space of a process. Contains the process (AbstractProcessDefinition), the model (AbstractModelDefinition), the phase space definition (AbstractPhasespaceDefinition), and stateful incoming and outgoing particles (ParticleStateful).\n\nThe legality of the combination of the given process and the incoming and outgoing particles is checked on construction. If the numbers of particles mismatch, the types of particles mismatch (note that order is important), or incoming particles have an Outgoing direction, an error is thrown.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> PhaseSpacePoint(\n            Compton(),\n            PerturbativeQED(),\n            PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n            (\n                ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Incoming(), Photon(), SFourMomentum(1, 0, 0, 0))\n            ),\n            (\n                ParticleStateful(Outgoing(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\n            )\n        )\nPhaseSpacePoint:\n    process: one-photon Compton scattering\n    model: perturbative QED\n    phasespace definition: spherical coordinates in electron rest frame\n    incoming particles:\n     -> incoming electron: [1.0, 0.0, 0.0, 0.0]\n     -> incoming photon: [1.0, 0.0, 0.0, 0.0]\n    outgoing particles:\n     -> outgoing electron: [1.0, 0.0, 0.0, 0.0]\n     -> outgoing photon: [1.0, 0.0, 0.0, 0.0]\n\nnote: Note\nPhaseSpacePoints can be constructed with only one of their in- or out-channel set. For this, see the special constructors InPhaseSpacePoint and OutPhaseSpacePoint. The InPhaseSpacePoint and OutPhaseSpacePoint type definitions can be used to dispatch on such PhaseSpacePoints. Note that a full PhaseSpacePoint containing both its in- and out-channel matches both, .i.e. psp isa InPhaseSpacePoint and psp isa OutPhaseSpacePoint both evaluate to true if psp contains both channels. A completely empty PhaseSpacePoint is not allowed.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.PhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{M}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}, Tuple{Vararg{ELEMENT, M}}}} where {N, M, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_momenta::NTuple{N,AbstractFourMomentum},\n    out_momenta::NTuple{M,AbstractFourMomentum},\n)\n\nConstruct the phase space point from given momenta of incoming and outgoing particles regarding a given process.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhaseSpacePoint-Union{Tuple{M}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{Real, N}}, Tuple{Vararg{Real, M}}}} where {N, M}","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_coords::NTuple{N,Real},\n    out_coords::NTuple{M,Real},\n)\n\nConstruct a PhaseSpacePoint from given coordinates by using the _generate_momenta interface.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhasespaceDefinition","page":"Home","title":"QEDcore.PhasespaceDefinition","text":"PhasespaceDefinition(coord_sys::AbstractCoordinateSystem, frame::AbstractFrameOfReference)\n\nConvenient type to dispatch on coordiante systems and frames of reference. Combines a AbstractCoordinateSystem with a AbstractFrameOfReference.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Photon","page":"Home","title":"QEDcore.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Photon()\nphoton\n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Photon) = 0.0\ncharge(::Photon) = 0.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Positron","page":"Home","title":"QEDcore.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Positron()\npositron\n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Positron) = 1.0\ncharge(::Positron) = 1.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SFourMomentum","page":"Home","title":"QEDcore.SFourMomentum","text":"struct SFourMomentum <: AbstractFourMomentum\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"Home","title":"QEDcore.SFourMomentum","text":"SFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nSFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> SFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.SLorentzVector","page":"Home","title":"QEDcore.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SphericalCoordinateSystem","page":"Home","title":"QEDcore.SphericalCoordinateSystem","text":"SphericalCoordinateSystem <: AbstractCoordinateSystem\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#Base.getindex-Tuple{PhaseSpacePoint, Incoming, Int64}","page":"Home","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Incoming, n::Int)\n\nOverload for the array indexing operator []. Returns the nth incoming particle in this phase space point.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{PhaseSpacePoint, Outgoing, Int64}","page":"Home","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Outgoing, n::Int)\n\nOverload for the array indexing operator []. Returns the nth outgoing particle in this phase space point.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._momentum_type-Union{Tuple{Type{T}}, Tuple{T}, Tuple{E}, Tuple{O}, Tuple{I}, Tuple{D}, Tuple{M}, Tuple{P}} where {P, M, D, I, O, E, T<:PhaseSpacePoint{P, M, D, I, O, E}}","page":"Home","title":"QEDcore._momentum_type","text":"_momentum_type(psp::PhaseSpacePoint)\n_momentum_type(type::Type{PhaseSpacePoint})\n\nReturns the element type of the PhaseSpacePoint object or type, e.g. SFourMomentum.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> psp = PhaseSpacePoint(Compton(), PerturbativeQED(), PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()), Tuple(rand(SFourMomentum) for _ in 1:2), Tuple(rand(SFourMomentum) for _ in 1:2));\n\njulia> QEDcore._momentum_type(psp)\nSFourMomentum\n\njulia> QEDcore._momentum_type(typeof(psp))\nSFourMomentum\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(aBS::AdjointBiSpinor, BS::BiSpinor) -> ComplexF64\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, DiracMatrix, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix,\n    BS::BiSpinor\n) -> ComplexF64\n\n\nTensor product of Dirac matrix sandwiched between an adjoint and a standard bi-spinor resulting in a scalar.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, DiracMatrix}","page":"Home","title":"QEDcore._mul","text":"_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix\n) -> AdjointBiSpinor\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{BiSpinor, AdjointBiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(BS::BiSpinor, aBS::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{DiracMatrix, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(DM::DiracMatrix, BS::BiSpinor) -> BiSpinor\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{DiracMatrix, DiracMatrix}","page":"Home","title":"QEDcore._mul","text":"_mul(DM1::DiracMatrix, DM2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"}]
}
