var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QEDcore","category":"page"},{"location":"#QEDcore","page":"Home","title":"QEDcore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QEDcore.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QEDcore]","category":"page"},{"location":"#QEDcore.AbstractAxisBeta","page":"Home","title":"QEDcore.AbstractAxisBeta","text":"AbstractAxisBeta{T} <: AbstractAxisBoostParameter{T}\n\nAn abstract base type for the beta (velocity) parameter of type T, representing a Lorentz boost along a specific spatial axis.\n\nAbstractAxisBeta{T} extends AbstractAxisBoostParameter{T} and provides a general framework for defining beta parameters associated with individual Cartesian axes (x, y, z) in special relativity. The parameter T typically represents the numeric type (e.g., Float64, Float32) used for the beta value.\n\nUsage\n\nConcrete subtypes of AbstractAxisBeta{T} define the beta parameters for Lorentz boosts along the x, y, and z axes:\n\nBetaX{T}: Boost parameter for the x-axis.\nBetaY{T}: Boost parameter for the y-axis.\nBetaZ{T}: Boost parameter for the z-axis.\n\nThese beta parameters are essential for performing axis-specific Lorentz boosts, which transform physical quantities such as four-momentum between different inertial frames.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractAxisBoostParameter","page":"Home","title":"QEDcore.AbstractAxisBoostParameter","text":"AbstractAxisBoostParameter{T}\n\nAn abstract base type representing a boost parameter of type T, associated with a specific axis in space (e.g., x, y, or z).\n\nThis type serves as a foundation for concrete boost parameter types that define Lorentz boosts along individual spatial directions. The parameter T typically represents the data type for the boost value (e.g., Float64, Float32).\n\nUsage\n\nSubtypes of AbstractAxisBoostParameter{T} are used to define specific boost transformations along a given axis (such as BetaX for the x-axis). These types are essential in performing Lorentz boosts, which transform four-momentum vectors between different inertial reference frames.\n\nThis abstract type is meant to be extended by concrete types to represent boosts along different Cartesian axes.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractBoostParameter","page":"Home","title":"QEDcore.AbstractBoostParameter","text":"AbstractBoostParameter\n\nAn abstract base type representing boost parameters used in Lorentz transformations, which describe the relative motion between two inertial frames in special relativity.\n\nAbstractBoostParameter serves as the foundation for defining specific boost parameters that control Lorentz boosts in different spatial directions. Boost parameters typically represent the velocity of one reference frame relative to another, expressed as a fraction of the speed of light (\\beta), and are essential for performing Lorentz transformations on four-vectors (such as SFourMomentum).\n\nOverview\n\nIn the context of special relativity, a Lorentz boost is a transformation that changes the time and spatial components of a four-vector based on the relative motion between two inertial reference frames. For example, the boost parameter beta is dimensionless and represents this velocity as a fraction of the speed of light. Depending on the frame's relative velocity, different forms of boost parameters exist, such as those associated with a single axis or a vector describing boosts in multiple spatial dimensions.\n\nThe AbstractBoostParameter type is the parent type for all specific kinds of boost parameters, including:\n\nAxis-specific Boost Parameters: Such as BetaX, which describes a boost along the x-axis.\nVector-like Boost Parameters: Such as BetaVector, which describes boosts with components in multiple spatial directions.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractBoostVector","page":"Home","title":"QEDcore.AbstractBoostVector","text":"AbstractBoostVector <: AbstractBoostParameter\n\nAn abstract base type representing vector-like boost parameters, used to model Lorentz boosts in any spatial dimension.\n\nAbstractBoostVector extends AbstractBoostParameter and provides the framework for describing boosts that act in multiple spatial dimensions simultaneously, typically in three-dimensional space. This type is designed to support vector representations of velocities (in units of the speed of light) associated with Lorentz transformations in special relativity.\n\nUsage\n\nConcrete subtypes of AbstractBoostVector represent specific boost vectors that describe the velocity components in each spatial dimension, such as BetaVector. These boost vectors are commonly used in transformations of four-vectors (e.g., four-momentum, four-position) between different reference frames.\n\nFor example:\n\nBetaVector{T}: A concrete subtype representing a boost vector with velocity components beta_x, beta_y, and beta_z (in units of the speed of light).\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractCoordinateTransformation","page":"Home","title":"QEDcore.AbstractCoordinateTransformation","text":"AbstractCoordinateTransformation\n\nAbstract base type for coordinate transformations supposed to be acting on four-momenta. Every subtype of trafo::AbstractCoordinateTransformation should implement the following interface functions:\n\nQEDcore._transform(trafo,p): transforms p\nBase.inv(trafo): returns the inverted transform\n\nExample\n\nImplementing the interface by defining the interface functions:\n\njulia> using QEDcore\n\njulia> struct TestTrafo{T} <: QEDcore.AbstractCoordinateTransformation\n           a::T\n       end\n\njulia> QEDcore._transform(trafo::TestTrafo,p) = trafo.a*p\n\njulia> Base.inv(trafo::TestTrafo) = TestTrafo(inv(trafo.a))\n\n\nThe TestTrafo can then be used to transform four-momenta:\n\njulia> trafo = TestTrafo(2.0)\nTestTrafo{Float64}(2.0)\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> trafo(p) # multiply every component with 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 8.0\n 6.0\n 4.0\n 2.0\n\njulia> inv(trafo)(p) # divide every component by 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 2.0\n 1.5\n 1.0\n 0.5\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractLorentzBoost","page":"Home","title":"QEDcore.AbstractLorentzBoost","text":"AbstractLorentzBoost <: AbstractLorentzTransformation\n\nAn abstract base type representing Lorentz boosts, a specific type of Lorentz transformation associated with relative motion between inertial frames along one or more spatial directions.\n\nAbstractLorentzBoost extends AbstractLorentzTransformation and serves as the foundation for all types of boost transformations in special relativity. Lorentz boosts describe how four-vectors (such as SFourMomentum) change when transitioning between two reference frames moving at constant velocities (in units of the speed of light) relative to each other.\n\nFor example:\n\nBoost{T}: A concrete implementation of Lorentz boosts with boost parameter T (see also AbstractBoostParameter).\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AbstractLorentzTransformation","page":"Home","title":"QEDcore.AbstractLorentzTransformation","text":"AbstractLorentzTransformation <: AbstractCoordinateTransformation\n\nAn abstract base type representing Lorentz transformations, which are coordinate transformations between inertial and reference frames in special relativity.\n\nAbstractLorentzTransformation extends AbstractCoordinateTransformation and provides the foundational framework for all types of Lorentz transformations, including boosts. These transformations preserve the Minkowski product of two four-vectors and are fundamental to the description of relativistic physics, ensuring the laws of physics are the same in all inertial frames.\n\nUsage\n\nSubtypes of AbstractLorentzTransformation implement specific kinds of Lorentz transformations. For example:\n\nBoost{T}: A concrete implementation of Lorentz boosts with boost parameter T (see also AbstractBoostParameter).\n\nThese subtypes perform transformations on four-vectors (such as SFourMomentum) between different inertial reference frames.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AdjointBiSpinor","page":"Home","title":"QEDcore.AdjointBiSpinor","text":"struct AdjointBiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model an adjoint Dirac four-spinor with complex-valued components. These are the elements of the dual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AntiBoson","page":"Home","title":"QEDcore.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.AntiFermion","page":"Home","title":"QEDcore.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion haveis_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BetaVector","page":"Home","title":"QEDcore.BetaVector","text":"BetaVector(x::Real,y::Real,z::Real)\n\nRepresents the spatial vector of velocity parameters (denoted as the \"beta\" vector) associated with motion in the three Cartesian directions, i.e., vecbeta = (beta_x beta_y beta_z). These components correspond to the velocity of an object (in units of the speed of light) in each of the x, y, and z directions.\n\nThe Lorentz boost along the direction of the beta vector vecbeta transforms the four-momentum as follows:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\n    gamma  (p_0 - vecbeta vec p)\np_1 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_x\np_2 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_y\n    p_3 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_z\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2.\n\nExample\n\njulia> using QEDcore\n\njulia> beta_vec = BetaVector(0.2,0.3,0.1)\nBetaVector{Float64}(0.2, 0.3, 0.1)\n\njulia> boost = Boost(beta_vec)\nBoost{BetaVector{Float64}}(BetaVector{Float64}(0.2, 0.3, 0.1))\n\njulia> p = SFourMomentum(4.0,3.0,2.0,1.0)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.911484876492837\n 2.282803602436349\n 0.9242054036545237\n 0.6414018012181746\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\nROOT::Math:Boost from ROOT\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BetaX","page":"Home","title":"QEDcore.BetaX","text":"BetaX(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the x-axis, commonly denoted as beta_x.\n\nThe transformation for a boost along the x-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_x p_1)\ngamma (p_1 - beta_x p_0)\np_2\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2)\n\nExample\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BetaY","page":"Home","title":"QEDcore.BetaY","text":"BetaY(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the y-axis, commonly denoted as beta_y.\n\nThe transformation for a boost along the y-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_y p_2)\np_1\ngamma (p_2 - beta_y p_0)\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_y^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_y = BetaY(0.5)\nBetaY{Float64}(0.5)\n\njulia> boost = Boost(beta_y)\nBoost{BetaY{Float64}}(BetaY{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 3.4641016151377553\n 3.0\n 0.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BetaZ","page":"Home","title":"QEDcore.BetaZ","text":"BetaZ(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the z-axis, commonly denoted as beta_z.\n\nThe transformation for a boost along the z-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_z p_3)\np_1\np_2\ngamma (p_3 - beta_z p_0)\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_z^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_z = BetaZ(0.5)\nBetaZ{Float64}(0.5)\n\njulia> boost = Boost(beta_z)\nBoost{BetaZ{Float64}}(BetaZ{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n  4.041451884327381\n  3.0\n  2.0\n -1.1547005383792517\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BiSpinor","page":"Home","title":"QEDcore.BiSpinor","text":"struct BiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model a Dirac four-spinor with complex-valued components. These are the elements of an actual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Boost","page":"Home","title":"QEDcore.Boost","text":"Boost{V<:AbstractBoostParameter} <: AbstractLorentzBoost\n\nA concrete type representing a Lorentz boost transformation, parameterized by a boost parameter V. The boost parameter can be either axis-specific or vector-like, depending on the subtype of AbstractBoostParameter used. The Boost type is used to perform Lorentz boosts on four-vectors (such as four-momentum or four-position) between different inertial frames in special relativity.\n\nFields\n\nparam::V: A boost parameter of type V, which is a subtype of AbstractBoostParameter.   This parameter defines the velocity (as a fraction of the speed of light, beta)   and the direction of the boost (e.g., along a single axis or in multiple directions).\n\nOverview\n\nA Lorentz boost is a transformation that adjusts the time and spatial components of a four-vector based on the relative velocity between two reference frames. The Boost struct provides a general and flexible implementation of such a boost, where the type of the boost parameter determines the direction and magnitude of the boost.\n\nDepending on the boost parameter V, the boost can be:\n\nAxis-specific: When V is an axis-specific boost parameter (e.g., BetaX), the   boost will be along that axis.\nVector-like: When V is a vector of boost parameters (e.g., BetaVector), the   boost will have components in multiple spatial directions.\n\nExample\n\nTo create a Lorentz boost along the x-axis using the BetaX boost parameter:\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost_x = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\nTo perform a Lorentz boost using the boost_x object, you can apply it to a four-vector, such as four-momentum:\n\njulia> p = SFourMomentum(4, 3, 2, 1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost_x(p)  # Perform the boost\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p, p_prime*p_prime)  # The invariant mass is preserved\n\nNotes\n\nThe Boost type provides a unified and flexible interface for applying Lorentz boosts, with the boost parameter V determining the specific form of the transformation. Lorentz boosts preserve the spacetime interval, meaning that applying the boost to a four-vector will not change the invariant quantity.\n\nSee Also\n\nAbstractBoostParameter: Base type for specific kinds of boost parameters.\nBetaX: Boost parameter for the x-axis.\nBetaY: Boost parameter for the y-axis.\nBetaZ: Boost parameter for the z-axis.\nBetaVector: Vector of boost parameters for boosts in multiple spatial directions.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Boson","page":"Home","title":"QEDcore.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.BosonLike","page":"Home","title":"QEDcore.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.CenterOfMomentumFrame","page":"Home","title":"QEDcore.CenterOfMomentumFrame","text":"CenterOfMomentumFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.DiracMatrix","page":"Home","title":"QEDcore.DiracMatrix","text":"struct DiracMatrix <: AbstractDiracMatrix{ComplexF64}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Electron","page":"Home","title":"QEDcore.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Electron()\nelectron\n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Electron) = 1.0\ncharge(::Electron) = -1.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.ElectronRestFrame","page":"Home","title":"QEDcore.ElectronRestFrame","text":"ElectronRestFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Fermion","page":"Home","title":"QEDcore.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.FermionLike","page":"Home","title":"QEDcore.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.InPhaseSpacePoint","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: OutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}}} where {N, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_momenta::NTuple{N,AbstractFourMomentum},\n)\n\nConstruct a PhaseSpacePoint with only input particles from given momenta. The result will be <: InPhaseSpacePoint but not <: OutPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{IN_PARTICLES}, Tuple{PSDEF}, Tuple{MODEL}, Tuple{PROC}, Tuple{PROC, MODEL, PSDEF, IN_PARTICLES}} where {PROC<:AbstractProcessDefinition, MODEL<:AbstractModelDefinition, PSDEF<:AbstractPhasespaceDefinition, IN_PARTICLES<:Tuple{Vararg{ParticleStateful}}}","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition, \n    model::AbstractModelDefinition, \n    ps_def::AbstractPhasespaceDefinition, \n    in_ps::Tuple{ParticleStateful},\n)\n\nConstruct a [`PhaseSpacePoint`](@ref) with only input particles from [`ParticleStateful`](@ref)s. The result will be `<: InPhaseSpacePoint` but **not** `<: OutPhaseSpacePoint`.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.InPhaseSpacePoint-Union{Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{Real, N}}}} where N","page":"Home","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_coords::NTuple{N,Real},\n)\n\nConstruct a PhaseSpacePoint from given coordinates by using the _generate_momenta interface. The result will be <: InPhaseSpacePoint but not <: OutPhaseSpacePoint.\n\nnote: Note\nA similar function for OutPhaseSpacePoint does not exist from coordinates, only a full PhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.MFourMomentum","page":"Home","title":"QEDcore.MFourMomentum","text":"mutable struct MFourMomentum <: AbstractFourMomentum\n\nBuilds a mutable LorentzVector with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"Home","title":"QEDcore.MFourMomentum","text":"MFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nMFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> MFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.MLorentzVector","page":"Home","title":"QEDcore.MLorentzVector","text":"mutable struct MLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic mutable Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MajoranaBoson","page":"Home","title":"QEDcore.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson haveis_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.MajoranaFermion","page":"Home","title":"QEDcore.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion haveis_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.OutPhaseSpacePoint","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: InPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.OutPhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}}} where {N, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    out_momenta::NTuple{N,AbstractFourMomentum},\n)\n\nConstruct a PhaseSpacePoint with only output particles from given momenta. The result will be <: OutPhaseSpacePoint but not <: InPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.OutPhaseSpacePoint-Union{Tuple{OUT_PARTICLES}, Tuple{PSDEF}, Tuple{MODEL}, Tuple{PROC}, Tuple{PROC, MODEL, PSDEF, OUT_PARTICLES}} where {PROC<:AbstractProcessDefinition, MODEL<:AbstractModelDefinition, PSDEF<:AbstractPhasespaceDefinition, OUT_PARTICLES<:Tuple{Vararg{ParticleStateful}}}","page":"Home","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint(\n    proc::AbstractProcessDefinition, \n    model::AbstractModelDefinition, \n    ps_def::AbstractPhasespaceDefinition, \n    out_ps::Tuple{ParticleStateful},\n)\n\nConstruct a PhaseSpacePoint with only output particles from ParticleStatefuls. The result will be <: OutPhaseSpacePoint but not <: InPhaseSpacePoint.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.ParticleStateful","page":"Home","title":"QEDcore.ParticleStateful","text":"ParticleStateful <: AbstractParticle\n\nRepresentation of a particle with a state. It has four fields:\n\ndir::ParticleDirection: The direction of the particle, Incoming() or Outgoing().\nspecies::AbstractParticleType: The species of the particle, Electron(), Positron() etc.\nmom::AbstractFourMomentum: The momentum of the particle.\n\nOverloads for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are provided, delegating the call to the correct field and thus implementing the AbstractParticle interface.\n\njulia> using QEDcore\n\njulia> ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: incoming electron\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\njulia> ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: outgoing photon\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.ParticleStateful-Union{Tuple{AbstractFourMomentum}, Tuple{SPECIES}, Tuple{DIR}} where {DIR<:ParticleDirection, SPECIES<:AbstractParticleType}","page":"Home","title":"QEDcore.ParticleStateful","text":"ParticleStateful{DIR, SPECIES}(mom::AbstractFourMomentum)\nParticleStateful{DIR, SPECIES, EL}(mom::EL)\n\nConstruct a ParticleStateful from the given momentum on a fully or partially specified type.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhaseSpacePoint","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint\n\nRepresentation of a point in the phase space of a process. Contains the process (AbstractProcessDefinition), the model (AbstractModelDefinition), the phase space definition (AbstractPhasespaceDefinition), and stateful incoming and outgoing particles (ParticleStateful).\n\nThe legality of the combination of the given process and the incoming and outgoing particles is checked on construction. If the numbers of particles mismatch, the types of particles mismatch (note that order is important), or incoming particles have an Outgoing direction, an error is thrown.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> PhaseSpacePoint(\n            Compton(),\n            PerturbativeQED(),\n            PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n            (\n                ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Incoming(), Photon(), SFourMomentum(1, 0, 0, 0))\n            ),\n            (\n                ParticleStateful(Outgoing(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\n            )\n        )\nPhaseSpacePoint:\n    process: one-photon Compton scattering\n    model: perturbative QED\n    phasespace definition: spherical coordinates in electron rest frame\n    incoming particles:\n     -> incoming electron: [1.0, 0.0, 0.0, 0.0]\n     -> incoming photon: [1.0, 0.0, 0.0, 0.0]\n    outgoing particles:\n     -> outgoing electron: [1.0, 0.0, 0.0, 0.0]\n     -> outgoing photon: [1.0, 0.0, 0.0, 0.0]\n\nnote: Note\nPhaseSpacePoints can be constructed with only one of their in- or out-channel set. For this, see the special constructors InPhaseSpacePoint and OutPhaseSpacePoint. The InPhaseSpacePoint and OutPhaseSpacePoint type definitions can be used to dispatch on such PhaseSpacePoints. Note that a full PhaseSpacePoint containing both its in- and out-channel matches both, .i.e. psp isa InPhaseSpacePoint and psp isa OutPhaseSpacePoint both evaluate to true if psp contains both channels. A completely empty PhaseSpacePoint is not allowed.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.PhaseSpacePoint-Union{Tuple{ELEMENT}, Tuple{M}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{ELEMENT, N}}, Tuple{Vararg{ELEMENT, M}}}} where {N, M, ELEMENT<:AbstractFourMomentum}","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_momenta::NTuple{N,AbstractFourMomentum},\n    out_momenta::NTuple{M,AbstractFourMomentum},\n)\n\nConstruct the phase space point from given momenta of incoming and outgoing particles regarding a given process.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhaseSpacePoint-Union{Tuple{M}, Tuple{N}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractPhasespaceDefinition, Tuple{Vararg{Real, N}}, Tuple{Vararg{Real, M}}}} where {N, M}","page":"Home","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint(\n    proc::AbstractProcessDefinition,\n    model::AbstractModelDefinition,\n    ps_def::AbstractPhasespaceDefinition,\n    in_coords::NTuple{N,Real},\n    out_coords::NTuple{M,Real},\n)\n\nConstruct a PhaseSpacePoint from given coordinates by using the _generate_momenta interface.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.PhasespaceDefinition","page":"Home","title":"QEDcore.PhasespaceDefinition","text":"PhasespaceDefinition(coord_sys::AbstractCoordinateSystem, frame::AbstractFrameOfReference)\n\nConvenient type to dispatch on coordiante systems and frames of reference. Combines a AbstractCoordinateSystem with a AbstractFrameOfReference.\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Photon","page":"Home","title":"QEDcore.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Photon()\nphoton\n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Photon) = 0.0\ncharge(::Photon) = 0.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.Positron","page":"Home","title":"QEDcore.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Positron()\npositron\n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Positron) = 1.0\ncharge(::Positron) = 1.0\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SFourMomentum","page":"Home","title":"QEDcore.SFourMomentum","text":"struct SFourMomentum <: AbstractFourMomentum\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SFourMomentum-Union{Tuple{T}, NTuple{4, T}} where T<:Union{Integer, Irrational, Rational}","page":"Home","title":"QEDcore.SFourMomentum","text":"SFourMomentum(t, x, y, z)\n\n\nThe interface transforms each number-like input to float64:\n\nSFourMomentum(\n    t::Union{Integer, Irrational, Rational},\n    x::Union{Integer, Irrational, Rational},\n    y::Union{Integer, Irrational, Rational},\n    z::Union{Integer, Irrational, Rational}\n) -> SFourMomentum\n\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore.SLorentzVector","page":"Home","title":"QEDcore.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.SphericalCoordinateSystem","page":"Home","title":"QEDcore.SphericalCoordinateSystem","text":"SphericalCoordinateSystem <: AbstractCoordinateSystem\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#Base.getindex-Tuple{PhaseSpacePoint, Incoming, Int64}","page":"Home","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Incoming, n::Int)\n\nOverload for the array indexing operator []. Returns the nth incoming particle in this phase space point.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{PhaseSpacePoint, Outgoing, Int64}","page":"Home","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Outgoing, n::Int)\n\nOverload for the array indexing operator []. Returns the nth outgoing particle in this phase space point.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._momentum_type-Union{Tuple{Type{T}}, Tuple{T}, Tuple{E}, Tuple{O}, Tuple{I}, Tuple{D}, Tuple{M}, Tuple{P}} where {P, M, D, I, O, E, T<:PhaseSpacePoint{P, M, D, I, O, E}}","page":"Home","title":"QEDcore._momentum_type","text":"_momentum_type(psp::PhaseSpacePoint)\n_momentum_type(type::Type{PhaseSpacePoint})\n\nReturns the element type of the PhaseSpacePoint object or type, e.g. SFourMomentum.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> psp = PhaseSpacePoint(Compton(), PerturbativeQED(), PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()), Tuple(rand(SFourMomentum) for _ in 1:2), Tuple(rand(SFourMomentum) for _ in 1:2));\n\njulia> QEDcore._momentum_type(psp)\nSFourMomentum\n\njulia> QEDcore._momentum_type(typeof(psp))\nSFourMomentum\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(aBS::AdjointBiSpinor, BS::BiSpinor) -> ComplexF64\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, DiracMatrix, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix,\n    BS::BiSpinor\n) -> ComplexF64\n\n\nTensor product of Dirac matrix sandwiched between an adjoint and a standard bi-spinor resulting in a scalar.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{AdjointBiSpinor, DiracMatrix}","page":"Home","title":"QEDcore._mul","text":"_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix\n) -> AdjointBiSpinor\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{BiSpinor, AdjointBiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(BS::BiSpinor, aBS::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{DiracMatrix, BiSpinor}","page":"Home","title":"QEDcore._mul","text":"_mul(DM::DiracMatrix, BS::BiSpinor) -> BiSpinor\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._mul-Tuple{DiracMatrix, DiracMatrix}","page":"Home","title":"QEDcore._mul","text":"_mul(DM1::DiracMatrix, DM2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n","category":"method"},{"location":"#QEDcore._transform","page":"Home","title":"QEDcore._transform","text":"_transform(trafo::AbstractCoordinateTransformation,p::AbstractFourMomentum)\n\nInterface function for the application of the transformation to the four-momentum p. Must return a four-momentum of the same type as p.\n\n\n\n\n\n","category":"function"}]
}
