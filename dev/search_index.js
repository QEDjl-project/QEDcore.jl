var documenterSearchIndex = {"docs":
[{"location":"library/phase_space_layout/#Phase-Space-Layout","page":"Phase Space Layout","title":"Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase Space Layout","title":"Phase Space Layout","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/phase_space_layout/#Coordinate-Maps","page":"Phase Space Layout","title":"Coordinate Maps","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase Space Layout","title":"Phase Space Layout","text":"CoordinateMap\nCoordinateMapCached","category":"page"},{"location":"library/phase_space_layout/#QEDcore.CoordinateMap","page":"Phase Space Layout","title":"QEDcore.CoordinateMap","text":"CoordinateMap{P,M,PSL}(proc::P, model::M, psl::PSL)\n\nA CoordinateMap represents a transformation that maps phase space coordinates to particle momenta for a specific scattering process. This type encapsulates the scattering process definition (proc), the physics model (model), and the phase space layout (psl). The CoordinateMap is callable and supports the conversion of both incoming and outgoing phase space coordinates into four-momenta.\n\nFields\n\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\npsl: The phase space layout, either incoming or outgoing, that maps coordinates to momenta.\n\nUsage\n\nIncoming Coordinates\n\nThe CoordinateMap can be called with a tuple of incoming phase space coordinates (in_coords), which are used to compute the corresponding incoming particle four-momenta. This is done by calling the phase space construction function QEDbase.build_momenta using the proc, model, and psl provided in the CoordinateMap.\n\n# Create a coordinate map for in phase space\nin_coord_map = CoordinateMap(proc, model, in_psl)\n\n# call on in-coordinates to build the momenta\nin_coord_map(in_coords)\n\nArguments:\nin_coords: A tuple of phase space coordinates for the incoming particles.\nReturns: A tuple of four-momenta corresponding to the incoming particles.\n\nIncoming and Outgoing Coordinates\n\nThe CoordinateMap can also be called with both incoming (in_coords) and outgoing (out_coords) phase space coordinates. The incoming momenta are computed first, and then the total momentum (Ptot) is calculated by summing these momenta. This total momentum is then used to compute the outgoing particle four-momenta using the provided outgoing phase space layout.\n\n# Create a coordinate map for out phase space\ncoord_map = CoordinateMap(proc, model, out_psl)\n\n# call on in- and out-coordinates to build the momenta\ncoord_map(in_coords, out_coords)\n\nArguments:\nin_coords: A tuple of phase space coordinates for the incoming particles.\nout_coords: A tuple of phase space coordinates for the outgoing particles.\nReturns:\nA tuple where the first element is the incoming particle momenta and the second element   is the outgoing particle momenta, both represented as tuples of four-momenta.\n\nNotes\n\nThe CoordinateMap provides a flexible mechanism for transforming phase space coordinates   into physically meaningful four-momenta, ensuring consistency with the scattering process,   physics model, and phase space layout.\nThe type is designed to handle both incoming and outgoing momenta, ensuring proper energy   and momentum conservation for the process.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.CoordinateMapCached","page":"Phase Space Layout","title":"QEDcore.CoordinateMapCached","text":"CoordinateMapCached{P,M,PSL,TM}(proc::P, model::M, psl::PSL, in_moms::TM)\n\nA CoordinateMapCached represents a precomputed transformation for phase space coordinates, where the momenta of the incoming particles are cached. This can improve performance in cases where the incoming momenta remain constant and only the outgoing momenta need to be computed based on new coordinates.\n\nThe cached map encapsulates the scattering process (proc), the physics model (model), the phase space layout (psl), and the precomputed incoming momenta (in_moms).\n\nFields\n\nproc: The scattering process definition, which defines the incoming and outgoing particles.\nmodel: The physics model, which governs the interaction type and momentum distributions.\npsl: The phase space layout, either incoming or outgoing, that maps coordinates to momenta.\nin_moms: A collection of precomputed four-momenta for the incoming particles, usually a Tuple.\n\nUsage\n\nCached Incoming Coordinates\n\nWhen a CoordinateMapCached build with psl::AbstractInPhaseSpaceLayout is called without any arguments, it returns the precomputed incoming momenta (in_moms) directly. This provides an efficient way to access the incoming particle momenta that have already been calculated and stored in the map.\n\n# Create a coordinate map for in phase space\nin_coord_map = CoordinateMapCached(proc, model, in_psl, in_moms)\n\n# call to return the in-momenta\nin_coord_map()\n\nReturns: The cached tuple of four-momenta for the incoming particles.\n\nOutgoing Coordinates\n\nThe CoordinateMapCached can be called with outgoing phase space coordinates (out_coords). The cached incoming momenta (in_moms) are used to compute the total momentum (Ptot), which is then passed along with the outgoing coordinates to compute the momenta of the outgoing particles.\n\n# Create a coordinate map for out phase space\nout_coord_map = CoordinateMapCached(proc, model, out_psl, in_moms)\n\n# call on out coordinates to return the out-momenta\nout_coord_map(out_coords)\n\nArguments:\nout_coords: A tuple of phase space coordinates for the outgoing particles.\nReturns:\nA tuple of four-momenta for the outgoing particles, consistent with the total momentum   derived from the cached incoming momenta.\n\nNotes\n\nCaching: The CoordinateMapCached is useful when the incoming momenta are fixed or do   not change frequently, as it avoids recomputation by storing the incoming momenta in the   cache.\nEfficiency: This caching mechanism can significantly enhance performance when repeatedly   evaluating the scattering process with fixed incoming particles but varying outgoing   configurations.\nThe type is designed to handle both incoming and outgoing momenta, ensuring proper energy   and momentum conservation for the process.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#Implementations","page":"Phase Space Layout","title":"Implementations","text":"","category":"section"},{"location":"library/phase_space_layout/#Two-body-Phase-Space-Layout","page":"Phase Space Layout","title":"Two-body Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/","page":"Phase Space Layout","title":"Phase Space Layout","text":"AbstractTwoBodyInPhaseSpaceLayout\nAbstractTwoBodyRestSystem\nTwoBodyRestSystem","category":"page"},{"location":"library/phase_space_layout/#QEDcore.AbstractTwoBodyInPhaseSpaceLayout","page":"Phase Space Layout","title":"QEDcore.AbstractTwoBodyInPhaseSpaceLayout","text":"AbstractTwoBodyInPhaseSpaceLayout <: AbstractInPhaseSpaceLayout\n\nAn abstract type representing an incoming phase space layout specifically designed for two-body systems in high-energy physics. This type is a specialized subtype of AbstractInPhaseSpaceLayout, focusing on scenarios where two particles are incoming and participate in a scattering or decay process.\n\nConcrete subtypes of AbstractTwoBodyInPhaseSpaceLayout define the parameterization of the momenta of the two incoming particles, such as by Energy, Rapidity, or other kinematic coordinates. These layouts allow for consistent calculation of the system's phase-space properties under conservation laws, facilitating method dispatch in functions like QEDbase._build_momenta.\n\nThis type serves as a foundation for implementing concrete layouts, ensuring that two-body processes can be modeled flexibly and accurately within phase space calculations.\n\nSee Also\n\nQEDbase.AbstractInPhaseSpaceLayout: A broader type for general incoming phase space layouts.\nAbstractTwoBodyRestSystem: A subtype representing two-body systems where one   particle is at rest.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.AbstractTwoBodyRestSystem","page":"Phase Space Layout","title":"QEDcore.AbstractTwoBodyRestSystem","text":"AbstractTwoBodyRestSystem <: AbstractTwoBodyInPhaseSpaceLayout\n\nAn abstract type representing the phase space layout of a two-body system in which one particle is at rest in the system's frame.\n\nConcrete subtypes of AbstractTwoBodyRestSystem typically specify the coordinate system used to parameterize the momentum of the non-resting particle, such as Energy, SpatialMagnitude, CenterOfMomentumEnergy, or Rapidity. The choice of coordinate system impacts how the momenta of the incoming particles are constructed.\n\nThis type serves as a base for defining custom layouts that rely on rest-frame assumptions for two-body scattering or decay processes, and it facilitates method dispatch in momentum construction functions like QEDbase._build_momenta.\n\nSee Also\n\nTwoBodyRestSystem: A concrete implementation of AbstractTwoBodyRestSystem that   supports various univariate coordinates for describing the non-resting particle.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.TwoBodyRestSystem","page":"Phase Space Layout","title":"QEDcore.TwoBodyRestSystem","text":"TwoBodyRestSystem{RESTIDX, COORD<:AbstractUnivariateCoordinate}\n\nRepresents a two-body scattering system in the rest frame of one of the particles, where one particle (identified by RESTIDX) is at rest and the other particle's momentum is described by a coordinate system COORD. The system uses various univariate coordinates, such as energy, rapidity, or center-of-momentum energy, to parameterize the momentum of the moving particle.\n\nThis type allows for easy construction of the incoming particle momenta using the phase space layout for two-body systems, commonly used in high-energy physics processes. The system supports different coordinate systems for defining the moving particle's momenta, including energy-based and rapidity-based layouts.\n\nFields\n\ncoord::COORD: The coordinate type (COORD) used to describe the non-resting particle's momenta.\n\nSupported Coordinates\n\nEnergy: Defines the energy of the moving particle.\nSpatialMagnitude: Defines the spatial momentum magnitude of the moving particle.\nCMSEnergy: Defines the total center-of-mass energy of the system.\nRapidity: Defines the rapidity of the moving particle.\n\nExample Usages\n\nThe following examples show how to use different coordinate systems with TwoBodyRestSystem in conjunction with the _build_momenta interface.\n\nExample 1: Using Energy Coordinate\n\npsl = TwoBodyRestSystem(Energy(2))  # Particle 1 at rest, particle 2 described by its energy\nin_coords = (100.0,)  # Energy of particle 2\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nThis constructs the momenta assuming particle 1 is at rest, and particle 2 has an energy of 100 GeV.\n\nExample 2: Using SpatialMagnitude Coordinate\n\npsl = TwoBodyRestSystem(SpatialMagnitude(2))  # Particle 1 at rest, particle 2 described by its spatial magnitude\nin_coords = (50.0,)  # Spatial momentum magnitude of particle 2\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nIn this case, the moving particle's spatial momentum magnitude is given, and its energy is calculated based on its mass.\n\nExample 3: Using CMSEnergy Coordinate\n\npsl = TwoBodyRestSystem(1,CMSEnergy())  # Particle 1 at rest, particle 2 described by the center-of-mass energy\nin_coords = (200.0,)  # Total center-of-mass energy of the system\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nHere, the center-of-mass energy of the system is provided, and the momenta of both particles are calculated while conserving energy and momentum.\n\nExample 4: Using Rapidity Coordinate\n\npsl = TwoBodyRestSystem(Rapidity(2))  # Particle 1 at rest, particle 2 described by its rapidity\nin_coords = (1.0,)  # Rapidity of particle 2\nmomenta = _build_momenta(proc, model, psl, in_coords)\n@assert isapprox(getMass(sum(momenta)),50.0)\n\nIn this case, the rapidity of particle 2 is given, and its energy and momentum are computed based on this parameter.\n\nNotes\n\nRESTIDX is the index of the particle that is at rest in the system.\nCOORD specifies the coordinate type of the non-resting particle and must be a subtype of   AbstractUnivariateCoordinate.\nThe coordinate system should be compatible with the given particles and their masses,   otherwise, an error may occur during momentum construction.\n\nThrows\n\nArgumentError if invalid coordinates are used (e.g., unsupported coordinate types or   incompatible indices).\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"library/particles/#Particle-Types","page":"Particles","title":"Particle Types","text":"","category":"section"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"The following are subtypes of QEDbase.AbstractParticleType(@extref).","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"For all these types the corresponding interface is implemented, including QEDbase.base_state(@extref) and QEDbase.propagator(@extref).","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"FermionLike\nBosonLike\nMajoranaFermion\nMajoranaBoson\nFermion\nBoson\nAntiFermion\nAntiBoson\nElectron\nPositron\nPhoton","category":"page"},{"location":"library/particles/#QEDcore.FermionLike","page":"Particles","title":"QEDcore.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.BosonLike","page":"Particles","title":"QEDcore.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaFermion","page":"Particles","title":"QEDcore.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion haveis_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaBoson","page":"Particles","title":"QEDcore.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson haveis_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Fermion","page":"Particles","title":"QEDcore.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Boson","page":"Particles","title":"QEDcore.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiFermion","page":"Particles","title":"QEDcore.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion haveis_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiBoson","page":"Particles","title":"QEDcore.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Electron","page":"Particles","title":"QEDcore.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Electron()\nelectron\n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Electron) = 1.0\ncharge(::Electron) = -1.0\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Positron","page":"Particles","title":"QEDcore.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Positron()\npositron\n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Positron) = 1.0\ncharge(::Positron) = 1.0\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Photon","page":"Particles","title":"QEDcore.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Photon()\nphoton\n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Photon) = 0.0\ncharge(::Photon) = 0.0\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Index","title":"Index","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/#QEDcore","page":"Index","title":"QEDcore","text":"","category":"section"},{"location":"library/","page":"Index","title":"Index","text":"API index for QEDcore.","category":"page"},{"location":"library/","page":"Index","title":"Index","text":"","category":"page"},{"location":"library/phasespacepoint/#Phase-Space-Points","page":"Phase Space Points","title":"Phase Space Points","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/phasespacepoint/#Types-and-Aliases","page":"Phase Space Points","title":"Types and Aliases","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"ParticleStateful\nPhaseSpacePoint\nInPhaseSpacePoint\nOutPhaseSpacePoint","category":"page"},{"location":"library/phasespacepoint/#QEDcore.ParticleStateful","page":"Phase Space Points","title":"QEDcore.ParticleStateful","text":"ParticleStateful <: AbstractParticle\n\nRepresentation of a particle with a state. It has four fields:\n\ndir::ParticleDirection: The direction of the particle, Incoming() or Outgoing().\nspecies::AbstractParticleType: The species of the particle, Electron(), Positron() etc.\nmom::AbstractFourMomentum: The momentum of the particle.\n\nOverloads for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are provided, delegating the call to the correct field and thus implementing the AbstractParticle interface.\n\njulia> using QEDcore\n\njulia> ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: incoming electron\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\njulia> ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: outgoing photon\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.PhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint\n\nRepresentation of a point in the phase space of a process. Contains the process (AbstractProcessDefinition), the model (AbstractModelDefinition), the phase space definition (AbstractPhasespaceDefinition), and stateful incoming and outgoing particles (ParticleStateful).\n\nThe legality of the combination of the given process and the incoming and outgoing particles is checked on construction. If the numbers of particles mismatch, the types of particles mismatch (note that order is important), or incoming particles have an Outgoing direction, an error is thrown.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> PhaseSpacePoint(\n            Compton(),\n            PerturbativeQED(),\n            PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n            (\n                ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Incoming(), Photon(), SFourMomentum(1, 0, 0, 0))\n            ),\n            (\n                ParticleStateful(Outgoing(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\n            )\n        )\nPhaseSpacePoint:\n    process: one-photon Compton scattering\n    model: perturbative QED\n    phasespace definition: spherical coordinates in electron rest frame\n    incoming particles:\n     -> incoming electron: [1.0, 0.0, 0.0, 0.0]\n     -> incoming photon: [1.0, 0.0, 0.0, 0.0]\n    outgoing particles:\n     -> outgoing electron: [1.0, 0.0, 0.0, 0.0]\n     -> outgoing photon: [1.0, 0.0, 0.0, 0.0]\n\nnote: Note\nPhaseSpacePoints can be constructed with only one of their in- or out-channel set. For this, see the special constructors InPhaseSpacePoint and OutPhaseSpacePoint. The InPhaseSpacePoint and OutPhaseSpacePoint type definitions can be used to dispatch on such PhaseSpacePoints. Note that a full PhaseSpacePoint containing both its in- and out-channel matches both, .i.e. psp isa InPhaseSpacePoint and psp isa OutPhaseSpacePoint both evaluate to true if psp contains both channels. A completely empty PhaseSpacePoint is not allowed.\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.InPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: OutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.OutPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: InPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#Accessors","page":"Phase Space Points","title":"Accessors","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"getindex\n_momentum_type","category":"page"},{"location":"library/phasespacepoint/#Base.getindex","page":"Phase Space Points","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Incoming, n::Int)\n\nOverload for the array indexing operator []. Returns the nth incoming particle in this phase space point.\n\n\n\n\n\nBase.getindex(psp::PhaseSpacePoint, dir::Outgoing, n::Int)\n\nOverload for the array indexing operator []. Returns the nth outgoing particle in this phase space point.\n\n\n\n\n\n","category":"function"},{"location":"library/phasespacepoint/#QEDcore._momentum_type","page":"Phase Space Points","title":"QEDcore._momentum_type","text":"_momentum_type(psp::PhaseSpacePoint)\n_momentum_type(type::Type{PhaseSpacePoint})\n\nReturns the element type of the PhaseSpacePoint object or type, e.g. SFourMomentum.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> psp = PhaseSpacePoint(Compton(), PerturbativeQED(), PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()), Tuple(rand(SFourMomentum) for _ in 1:2), Tuple(rand(SFourMomentum) for _ in 1:2));\n\njulia> QEDcore._momentum_type(psp)\nSFourMomentum\n\njulia> QEDcore._momentum_type(typeof(psp))\nSFourMomentum\n\n\n\n\n\n","category":"function"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"particles.md\", \"phasespacedef.md\", \"phasespacepoint.md\", \"vectors.md\"]","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"EditURL = \"../tutorial/particles.jl\"","category":"page"},{"location":"generated/particles/#Particles-and-Phase-Space-Points","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"There are three layers of abstraction from particles to phase space points in the QEDjl project:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"QEDbase.AbstractParticleType: Base type for singleton particle type definitions. We also call these species.\nQEDbase.AbstractParticleStateful: Base type for particles with a direction and carrying a momentum.\nQEDbase.AbstractPhaseSpacePoint: Representation of a point in the phase space for a combination of an QEDbase.AbstractProcessDefinition, QEDbase.AbstractModelDefinition, and QEDbase.AbstractPhasespaceDefinition.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This manual is intended to showcase the basic usage of these types and their implementations in QEDcore.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"struct UnexpectedSuccess <: Exception end # hide\nusing QEDcore","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"To use concrete process definitions and models, we also need to use QEDprocesses.jl","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"using QEDprocesses","category":"page"},{"location":"generated/particles/#Particle-Types","page":"Particles and Phase Space Points","title":"Particle Types","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"QEDcore currently defines the three basic particle types of QED, Electron, Positron, and Photon, and a type hierarchy for them:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert Photon <: MajoranaBoson\n@assert Electron <: Fermion\n@assert Positron <: AntiFermion","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"All of these are subtypes of QEDbase.AbstractParticleType. There are also convenience functions in Julia convention:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert is_boson(Photon())\n@assert is_particle(Electron())\n@assert is_anti_particle(Positron())\n\n@assert !is_boson(Electron())\n@assert !is_anti_particle(Electron())\n@assert !is_fermion(Photon())","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"These functions are part of QEDbase.jl's particle interface.","category":"page"},{"location":"generated/particles/#ParticleStateful","page":"Particles and Phase Space Points","title":"ParticleStateful","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"ParticleStateful is the implementation of QEDbase's QEDbase.AbstractParticleStateful interface. It represents a particle with a direction (as used in the context of scattering processes, QEDbase.Incoming, QEDbase.Outgoing, or QEDbase.UnknownDirection), a particle species (Electron, Positron, Photon, ...), and a 4-momentum vector.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"ps = ParticleStateful(Incoming(), Electron(), rand(SFourMomentum))","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"The relevant accessor functions for the interface are implemented:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particle_direction(ps)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particle_species(ps)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"momentum(ps)","category":"page"},{"location":"generated/particles/#Phase-Space-Points","page":"Particles and Phase Space Points","title":"Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"A PhaseSpacePoint is the combination of incoming and outgoing ParticleStatefuls. It also contains information about the scattering process, model, and phase space that it is created for.","category":"page"},{"location":"generated/particles/#Constructors","page":"Particles and Phase Space Points","title":"Constructors","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),                      # scattering process\n    PerturbativeQED(),              # physics model\n    PhasespaceDefinition(           # phase space definition\n        SphericalCoordinateSystem(),# coordinate system\n        ElectronRestFrame(),        # frame of reference\n    ),\n    (   # momenta of the incoming particles\n        rand(SFourMomentum),\n        rand(SFourMomentum),\n    ),\n    (   # momenta of the outgoing particles\n        rand(SFourMomentum),\n        rand(SFourMomentum),\n    ),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This version of the constructor automatically creates ParticleStateful obejcts from the momenta, matching the particles of the process. In the case of Compton, this is means an incoming electron and photon, and outgoing electron and photon.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Automatic checks make sure that the number of 4-momenta given matches the necessary number of 4-momenta for the process (this adds 0 overhead at runtime because it is inferred from type information alone).","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"try # hide\n    PhaseSpacePoint(\n        Compton(),\n        PerturbativeQED(),\n        PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n        (rand(SFourMomentum),), # incorrect number of incoming momenta, should be 2\n        (rand(SFourMomentum), rand(SFourMomentum)),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Alternatively, a PhaseSpacePoint can also be constructed from already existing ParticleStateful objects.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),                      # scattering process\n    PerturbativeQED(),              # physics model\n    PhasespaceDefinition(           # phase space definition\n        SphericalCoordinateSystem(),# coordinate system\n        ElectronRestFrame(),        # frame of reference\n    ),\n    (   # incoming particles\n        ParticleStateful(Incoming(), Electron(), rand(SFourMomentum)),\n        ParticleStateful(Incoming(), Photon(), rand(SFourMomentum)),\n    ),\n    (   # outgoing particles\n        ParticleStateful(Outgoing(), Electron(), rand(SFourMomentum)),\n        ParticleStateful(Outgoing(), Photon(), rand(SFourMomentum)),\n    ),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Similar to the constructor from momenta, this checks that the given ParticleStatefuls fit to the given process and throws otherwise. Again, since this can be infered from type information alone, it adds no overhead.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"try # hide\n    PhaseSpacePoint(\n        Compton(),\n        PerturbativeQED(),\n        PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n        (   # incoming particles\n            ParticleStateful(Incoming(), Positron(), rand(SFourMomentum)), # incorrect particle type\n            ParticleStateful(Incoming(), Photon(), rand(SFourMomentum)),\n        ),\n        (   # outgoing particles\n            ParticleStateful(Outgoing(), Electron(), rand(SFourMomentum)),\n            ParticleStateful(Outgoing(), Photon(), rand(SFourMomentum)),\n        ),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nWhile these constructors check that the given types make sense and work together, they do not check whether the given momenta make a physical phase space point or that the incoming or outgoing particles have on-shell 4-momenta.","category":"page"},{"location":"generated/particles/#Accessors","page":"Particles and Phase Space Points","title":"Accessors","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"The phase space point provides some convenient accessors to the stateful particles within:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp[Incoming(), 1]  # the first incoming particle","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp[Outgoing(), 2]  # the second outgoing particle","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particles(psp, Incoming()) # all incoming particles as a tuple","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Momentum accessors:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"momentum(psp, Incoming(), Electron(), 1) # the momentum of the first incoming electron","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"When only one particle of the species exists in the particle set, the 1 can be ommitted for convenience.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert ans == momentum(psp, Incoming(), Electron())","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nThis method throws when multiple (or zero) particles of the given direction and species exist in the phase space point.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"When the index of the required momentum is known at compile time, a Val(N) can be used instead of N. This performs bounds checks at compile time and removes loops from the runtime execution","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"using BenchmarkTools\njudge(\n    median(@benchmark momentum($psp, Incoming(), Photon(), Val(1))),\n    median(@benchmark momentum($psp, Incoming(), Photon(), 1)),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nThis is only faster when N is actually known at compile time, for example when it is a literal integer or a function's type parameter. For dynamic values of N, prefer the Int variant or in case of loops, directly loop over the tuple of momenta.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Some more overloads for the momentum function exist, for a complete list please refer to its documentation: QEDbase.momentum, QEDbase.momenta.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Finally, process, model, and phase_space_definition can be used to request the object in question:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"process(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"model(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"phase_space_definition(psp)","category":"page"},{"location":"generated/particles/#In/Out-Phase-Space-Points","page":"Particles and Phase Space Points","title":"In/Out Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"As a special case, phase space points are allowed to only contain the incoming or outgoing particle momenta. These types can be helpful for overloading some functions that don't require the entire phase space point to exist.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"function in_sum(in_psp::AbstractInPhaseSpacePoint)\n    return sum(momenta(in_psp, Incoming()))\nend\n\npsp = InPhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\nin_sum(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Every full PhaseSpacePoint is both an InPhaseSpacePoint and an OutPhaseSpacePoint, too. For example, the in_sum function defined above still works with a full PhaseSpacePoint:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\nin_sum(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"But an InPhaseSpacePoint is not an OutPhaseSpacePoint and vice versa. We cannot call in_sum on an OutPhaseSpacePoint:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = OutPhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\ntry # hide\n    in_sum(psp)\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"EditURL = \"../tutorial/ps_def.jl\"","category":"page"},{"location":"generated/ps_def/#Phase-Space-Definition","page":"Phase Space Definitions","title":"Phase Space Definition","text":"","category":"section"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"note: Note\nPhasespaceDefinitions are to be reworked (see this issue). Therefore, this manual is very rudimentary for the moment.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"A PhasespaceDefinition is a representation of a phase space's layout. It is a singleton type definition and has an AbstractCoordinateSystem and an AbstractFrameOfReference.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"using QEDcore\nps_def = PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame())","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"The phase space definition is used in PhaseSpacePoints for dispatching in some of the cross-section interface functions.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/lorentzboosts/#Lorentz-Boosts","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"","category":"section"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"The following is an implementation of the Lorentz Boost Interface of QEDbase.jl.","category":"page"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"Boost\nBetaVector\nBetaX\nBetaY\nBetaZ","category":"page"},{"location":"library/lorentzboosts/#QEDcore.Boost","page":"Lorentz Boosts","title":"QEDcore.Boost","text":"Boost{V<:QEDbase.AbstractBoostParameter} <: QEDbase.AbstractLorentzBoost\n\nA concrete type representing a Lorentz boost transformation, parameterized by a boost parameter V. The boost parameter can be either axis-specific or vector-like, depending on the subtype of QEDbase.AbstractBoostParameter used. The Boost type is used to perform Lorentz boosts on four-vectors (such as four-momentum or four-position) between different inertial frames in special relativity.\n\nFields\n\nparam::V: A boost parameter of type V, which is a subtype of AbstractBoostParameter.   This parameter defines the velocity (as a fraction of the speed of light, beta)   and the direction of the boost (e.g., along a single axis or in multiple directions).\n\nOverview\n\nA Lorentz boost is a transformation that adjusts the time and spatial components of a four-vector based on the relative velocity between two reference frames. The Boost struct provides a general and flexible implementation of such a boost, where the type of the boost parameter determines the direction and magnitude of the boost.\n\nDepending on the boost parameter V, the boost can be:\n\nAxis-specific: When V is an axis-specific boost parameter (e.g., BetaX), the   boost will be along that axis.\nVector-like: When V is a vector of boost parameters (e.g., BetaVector), the   boost will have components in multiple spatial directions.\n\nExample\n\nTo create a Lorentz boost along the x-axis using the BetaX boost parameter:\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost_x = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\nTo perform a Lorentz boost using the boost_x object, you can apply it to a four-vector, such as four-momentum:\n\njulia> p = SFourMomentum(4, 3, 2, 1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost_x(p)  # Perform the boost\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p, p_prime*p_prime)  # The invariant mass is preserved\n\nNotes\n\nThe Boost type provides a unified and flexible interface for applying Lorentz boosts, with the boost parameter V determining the specific form of the transformation. Lorentz boosts preserve the spacetime interval, meaning that applying the boost to a four-vector will not change the invariant quantity.\n\nSee Also\n\nQEDbase.AbstractBoostParameter: Base type for specific kinds of boost parameters.\nBetaX: Boost parameter for the x-axis.\nBetaY: Boost parameter for the y-axis.\nBetaZ: Boost parameter for the z-axis.\nBetaVector: Vector of boost parameters for boosts in multiple spatial directions.\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaVector","page":"Lorentz Boosts","title":"QEDcore.BetaVector","text":"BetaVector(x::Real,y::Real,z::Real)\n\nRepresents the spatial vector of velocity parameters (denoted as the \"beta\" vector) associated with motion in the three Cartesian directions, i.e., vecbeta = (beta_x beta_y beta_z). These components correspond to the velocity of an object (in units of the speed of light) in each of the x, y, and z directions.\n\nThe Lorentz boost along the direction of the beta vector vecbeta transforms the four-momentum as follows:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\n    gamma  (p_0 - vecbeta vec p)\np_1 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_x\np_2 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_y\n    p_3 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_z\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2.\n\nExample\n\njulia> using QEDcore\n\njulia> beta_vec = BetaVector(0.2,0.3,0.1)\nBetaVector{Float64}(0.2, 0.3, 0.1)\n\njulia> boost = Boost(beta_vec)\nBoost{BetaVector{Float64}}(BetaVector{Float64}(0.2, 0.3, 0.1))\n\njulia> p = SFourMomentum(4.0,3.0,2.0,1.0)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.911484876492837\n 2.282803602436349\n 0.9242054036545237\n 0.6414018012181746\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\nROOT::Math:Boost from ROOT\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaX","page":"Lorentz Boosts","title":"QEDcore.BetaX","text":"BetaX(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the x-axis, commonly denoted as beta_x.\n\nThe transformation for a boost along the x-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_x p_1)\ngamma (p_1 - beta_x p_0)\np_2\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2)\n\nExample\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaY","page":"Lorentz Boosts","title":"QEDcore.BetaY","text":"BetaY(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the y-axis, commonly denoted as beta_y.\n\nThe transformation for a boost along the y-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_y p_2)\np_1\ngamma (p_2 - beta_y p_0)\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_y^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_y = BetaY(0.5)\nBetaY{Float64}(0.5)\n\njulia> boost = Boost(beta_y)\nBoost{BetaY{Float64}}(BetaY{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 3.4641016151377553\n 3.0\n 0.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaZ","page":"Lorentz Boosts","title":"QEDcore.BetaZ","text":"BetaZ(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the z-axis, commonly denoted as beta_z.\n\nThe transformation for a boost along the z-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_z p_3)\np_1\np_2\ngamma (p_3 - beta_z p_0)\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_z^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_z = BetaZ(0.5)\nBetaZ{Float64}(0.5)\n\njulia> boost = Boost(beta_z)\nBoost{BetaZ{Float64}}(BetaZ{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n  4.041451884327381\n  3.0\n  2.0\n -1.1547005383792517\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"EditURL = \"../tutorial/vectors.jl\"","category":"page"},{"location":"generated/vectors/#Vector-and-Matrix-Types","page":"Matrix and Vector Types","title":"Vector and Matrix Types","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"TBW","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"using QEDcore","category":"page"},{"location":"generated/vectors/#Lorentz-Vectors","page":"Matrix and Vector Types","title":"Lorentz Vectors","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"lv = rand(SLorentzVector)","category":"page"},{"location":"generated/vectors/#Bispinors-and-Adjoint-Bispinors","page":"Matrix and Vector Types","title":"Bispinors and Adjoint Bispinors","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"bs = rand(BiSpinor)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs = rand(AdjointBiSpinor)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs * bs","category":"page"},{"location":"generated/vectors/#Dirac-and-Gamma-Matrices","page":"Matrix and Vector Types","title":"Dirac and Gamma Matrices","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"gm = rand(DiracMatrix)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs * gm * bs","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/coordinates/#Coordinates","page":"Coordinates","title":"Coordinates","text":"","category":"section"},{"location":"library/coordinates/","page":"Coordinates","title":"Coordinates","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/coordinates/#Coordinate-Interface","page":"Coordinates","title":"Coordinate Interface","text":"","category":"section"},{"location":"library/coordinates/","page":"Coordinates","title":"Coordinates","text":"AbstractCoordinateSet\ncoordinate_names\ncoordinate_name\nAbstractSingleParticleCoordinate\nparticle_index","category":"page"},{"location":"library/coordinates/#QEDcore.AbstractCoordinateSet","page":"Coordinates","title":"QEDcore.AbstractCoordinateSet","text":"AbstractCoordinateSet{N}\n\nAn abstract type representing a set of coordinates with N elements.\n\nSubtypes of AbstractCoordinateSet used to define specific coordinate systems or layouts used to describe physical processes, such as phase-space parametrizations for scattering events. The parameter N specifies the number of coordinates in the set, where N can be one for univariate coordinates (e.g., energy, rapidity) or higher for more complex systems.\n\nType Parameters\n\nN: The number of coordinates in the set.\n\nIntended Usage\n\nSubtypes of AbstractCoordinateSet{N} implement the structure and behavior for specific coordinate systems. Functions like coordinate_names and coordinate_name are used to retrieve human-readable names for the coordinates in the set.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.coordinate_names","page":"Coordinates","title":"QEDcore.coordinate_names","text":"coordinate_names(coord_set::AbstractCoordinateSet)\n\nRetrieve the names of all coordinates in a given coordinate set.\n\nArguments\n\ncoord_set::AbstractCoordinateSet: A coordinate set, which is a container for multiple\n\ncoordinates.\n\nReturns\n\nA tuple of strings, where each string is the name of a coordinate in the set, including its particle index if available.\n\nThis function is typically implemented for subtypes of AbstractCoordinateSet and is used to return human-readable names for each coordinate in the set.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#QEDcore.coordinate_name","page":"Coordinates","title":"QEDcore.coordinate_name","text":"coordinate_name(coord::AbstractUnivariateCoordinate)\n\nRetrieve the name of a single univariate coordinate.\n\nArguments\n\ncoord::AbstractUnivariateCoordinate: A single univariate coordinate, which is a subtype of AbstractCoordinateSet{1} representing a coordinate system with one degree of freedom.\n\nReturns\n\nA string representing the name of the coordinate.\n\nThis function provides a human-readable label for a single coordinate and is generally used for naming individual coordinates in a scattering process or phase space.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#QEDcore.AbstractSingleParticleCoordinate","page":"Coordinates","title":"QEDcore.AbstractSingleParticleCoordinate","text":"AbstractSingleParticleCoordinate{IDX} <: AbstractUnivariateCoordinate\n\nAn abstract type representing a coordinate associated with a single particle. The type parameter IDX indicates the index of the particle in an AbstractProcessDefintion, either for the in- or out-channel, depending on the phase phase layout. Specific types that inherit from this abstract type define various coordinates (e.g., energy, rapidity, etc.) for the particle.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.particle_index","page":"Coordinates","title":"QEDcore.particle_index","text":"particle_index(coord::AbstractSingleParticleCoordinate{IDX})\n\nReturn the index of the particle the coord is related to, i.e. IDX.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#Univariate-Coordinates","page":"Coordinates","title":"Univariate Coordinates","text":"","category":"section"},{"location":"library/coordinates/","page":"Coordinates","title":"Coordinates","text":"CenterOfMomentumEnergy\nEnergy\nSpatialMagnitude\nRapidity\nCosTheta","category":"page"},{"location":"library/coordinates/#QEDcore.CenterOfMomentumEnergy","page":"Coordinates","title":"QEDcore.CenterOfMomentumEnergy","text":"CenterOfMomentumEnergy <: AbstractUnivariateCoordinate\n\nRepresents the center-of-momentum (CoM) energy coordinate in the definion of a phase space layout.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.Energy","page":"Coordinates","title":"QEDcore.Energy","text":"Energy{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the energy coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.SpatialMagnitude","page":"Coordinates","title":"QEDcore.SpatialMagnitude","text":"SpatialMagnitude{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the spatial spatial magnitude for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.Rapidity","page":"Coordinates","title":"QEDcore.Rapidity","text":"Rapidity{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the rapidity coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.CosTheta","page":"Coordinates","title":"QEDcore.CosTheta","text":"CosTheta{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the cosine-theta coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#Multivariate-Coordinates","page":"Coordinates","title":"Multivariate Coordinates","text":"","category":"section"},{"location":"library/coordinates/","page":"Coordinates","title":"Coordinates","text":"CoordinateSet","category":"page"},{"location":"library/coordinates/#QEDcore.CoordinateSet","page":"Coordinates","title":"QEDcore.CoordinateSet","text":"CoordinateSet{N, D<:Tuple}\n\nA concrete type that represents a set of N coordinates, stored as a tuple coords::D. This type is a subtype of AbstractCoordinateSet{N} and is designed to handle sets of coordinates for use in various calculations, such as in phase space layouts.\n\nFields\n\ncoords::D: A tuple containing the individual coordinates. Each element of the tuple   corresponds to a coordinate in the set.\n\nConstructors\n\nCoordinateSet{N}(coords::D): Creates a CoordinateSet where the number of coordinates   N must match the length of the tuple coords. If they do not match,   an ArgumentError is thrown.\nCoordinateSet(coords::D): Automatically infers N as the length of the provided tuple   coords.\n\nThrows\n\nArgumentError if the length of the provided tuple does not match the specified   number N.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Vector-and-Matrix-Types","page":"Vector Types","title":"Vector and Matrix Types","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/vectors/#4-Momenta","page":"Vector Types","title":"4-Momenta","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"SFourMomentum\nMFourMomentum","category":"page"},{"location":"library/vectors/#QEDcore.SFourMomentum","page":"Vector Types","title":"QEDcore.SFourMomentum","text":"struct SFourMomentum <: AbstractFourMomentum\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.MFourMomentum","page":"Vector Types","title":"QEDcore.MFourMomentum","text":"mutable struct MFourMomentum <: AbstractFourMomentum\n\nBuilds a mutable LorentzVector with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Spinors","page":"Vector Types","title":"Spinors","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"BiSpinor\nAdjointBiSpinor","category":"page"},{"location":"library/vectors/#QEDcore.BiSpinor","page":"Vector Types","title":"QEDcore.BiSpinor","text":"struct BiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model a Dirac four-spinor with complex-valued components. These are the elements of an actual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.AdjointBiSpinor","page":"Vector Types","title":"QEDcore.AdjointBiSpinor","text":"struct AdjointBiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model an adjoint Dirac four-spinor with complex-valued components. These are the elements of the dual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Lorentz-Vectors","page":"Vector Types","title":"Lorentz Vectors","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"SLorentzVector\nMLorentzVector","category":"page"},{"location":"library/vectors/#QEDcore.SLorentzVector","page":"Vector Types","title":"QEDcore.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.MLorentzVector","page":"Vector Types","title":"QEDcore.MLorentzVector","text":"mutable struct MLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic mutable Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Dirac-Matrix","page":"Vector Types","title":"Dirac Matrix","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"DiracMatrix","category":"page"},{"location":"library/vectors/#QEDcore.DiracMatrix","page":"Vector Types","title":"QEDcore.DiracMatrix","text":"struct DiracMatrix <: AbstractDiracMatrix{ComplexF64}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Multiplications","page":"Vector Types","title":"Multiplications","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"_mul","category":"page"},{"location":"library/vectors/#QEDcore._mul","page":"Vector Types","title":"QEDcore._mul","text":"_mul(aBS::AdjointBiSpinor, BS::BiSpinor) -> ComplexF64\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(BS::BiSpinor, aBS::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(DM::DiracMatrix, BS::BiSpinor) -> BiSpinor\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix\n) -> AdjointBiSpinor\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(DM1::DiracMatrix, DM2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix,\n    BS::BiSpinor\n) -> ComplexF64\n\n\nTensor product of Dirac matrix sandwiched between an adjoint and a standard bi-spinor resulting in a scalar.\n\n\n\n\n\n","category":"function"},{"location":"library/phasespacedef/#Phase-Space-Definitions","page":"Phase Space Definition","title":"Phase Space Definitions","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/phasespacedef/#Phase-Space-Definition-Type","page":"Phase Space Definition","title":"Phase Space Definition Type","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"PhasespaceDefinition","category":"page"},{"location":"library/phasespacedef/#QEDcore.PhasespaceDefinition","page":"Phase Space Definition","title":"QEDcore.PhasespaceDefinition","text":"PhasespaceDefinition(coord_sys::AbstractCoordinateSystem, frame::AbstractFrameOfReference)\n\nConvenient type to dispatch on coordiante systems and frames of reference. Combines a AbstractCoordinateSystem with a AbstractFrameOfReference.\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#Frames-of-Reference","page":"Phase Space Definition","title":"Frames of Reference","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"CenterOfMomentumFrame\nElectronRestFrame","category":"page"},{"location":"library/phasespacedef/#QEDcore.CenterOfMomentumFrame","page":"Phase Space Definition","title":"QEDcore.CenterOfMomentumFrame","text":"CenterOfMomentumFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#QEDcore.ElectronRestFrame","page":"Phase Space Definition","title":"QEDcore.ElectronRestFrame","text":"ElectronRestFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#Coordinate-Systems","page":"Phase Space Definition","title":"Coordinate Systems","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"SphericalCoordinateSystem","category":"page"},{"location":"library/phasespacedef/#QEDcore.SphericalCoordinateSystem","page":"Phase Space Definition","title":"QEDcore.SphericalCoordinateSystem","text":"SphericalCoordinateSystem <: AbstractCoordinateSystem\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.jl","page":"Home","title":"QEDcore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is part of the QuantumElectrodynamics.jl library. For the description of the interoperability with other packages of QuantumElectrodynamics.jl see docs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package's main purpose is to provide implementations of the basic interfaces defined in QEDbase.jl, such as various particle types, PhasespaceDefinition, PhaseSpacePoint, and various vector and matrix types. These types are used across most of the QEDjl-project repositories. For detailed information on these types, please refer to the respective pages in the docs.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! If you'd like to report a bug, suggest an enhancement, or contribute code, please feel free to open an issue or submit a pull request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure consistency across the QuantumElectrodynamics.jl ecosystem, we encourage all contributors to review the QuantumElectrodynamics.jl contribution guide.","category":"page"},{"location":"#Credits-and-contributors","page":"Home","title":"Credits and contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germanys Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core code of the package QEDcore.jl is developed by a small team at the Center for Advanced Systems Understanding (CASUS), namely","category":"page"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uwe Hernandez Acosta (CASUS/HZDR, u.hernandez@hzdr.de)\nAnton Reinhard (CASUS/HZDR)\nSimeon Ehrig (CASUS/HZDR)","category":"page"},{"location":"#Former-Contributors","page":"Home","title":"Former Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We extend our sincere thanks to all contributors who have supported this project.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We extend our gratitude for the support received through direct and indirect funding for this project, especially","category":"page"},{"location":"","page":"Home","title":"Home","text":"Michael Bussmann\nTobias Dornheim","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT  Uwe Hernandez Acosta","category":"page"}]
}
