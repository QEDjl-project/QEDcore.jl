var documenterSearchIndex = {"docs":
[{"location":"library/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"library/particles/#Particle-Types","page":"Particles","title":"Particle Types","text":"","category":"section"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"The following are subtypes of QEDbase.AbstractParticleType(@extref).","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"For all these types the corresponding interface is implemented, including QEDbase.base_state(@extref) and QEDbase.propagator(@extref).","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/particles/","page":"Particles","title":"Particles","text":"FermionLike\nBosonLike\nMajoranaFermion\nMajoranaBoson\nFermion\nBoson\nAntiFermion\nAntiBoson\nElectron\nPositron\nPhoton","category":"page"},{"location":"library/particles/#QEDcore.FermionLike","page":"Particles","title":"QEDcore.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.BosonLike","page":"Particles","title":"QEDcore.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaFermion","page":"Particles","title":"QEDcore.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion haveis_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaBoson","page":"Particles","title":"QEDcore.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson haveis_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Fermion","page":"Particles","title":"QEDcore.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Boson","page":"Particles","title":"QEDcore.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiFermion","page":"Particles","title":"QEDcore.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion haveis_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiBoson","page":"Particles","title":"QEDcore.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Electron","page":"Particles","title":"QEDcore.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Electron()\nelectron\n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Electron) = 1.0\ncharge(::Electron) = -1.0\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Positron","page":"Particles","title":"QEDcore.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Positron()\npositron\n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Positron) = 1.0\ncharge(::Positron) = 1.0\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Photon","page":"Particles","title":"QEDcore.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Photon()\nphoton\n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Photon) = 0.0\ncharge(::Photon) = 0.0\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Index","title":"Index","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/#QEDcore","page":"Index","title":"QEDcore","text":"","category":"section"},{"location":"library/","page":"Index","title":"Index","text":"API index for QEDcore.","category":"page"},{"location":"library/","page":"Index","title":"Index","text":"","category":"page"},{"location":"library/phasespacepoint/#Phase-Space-Points","page":"Phase Space Points","title":"Phase Space Points","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/phasespacepoint/#Types-and-Aliases","page":"Phase Space Points","title":"Types and Aliases","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"ParticleStateful\nPhaseSpacePoint\nInPhaseSpacePoint\nOutPhaseSpacePoint","category":"page"},{"location":"library/phasespacepoint/#QEDcore.ParticleStateful","page":"Phase Space Points","title":"QEDcore.ParticleStateful","text":"ParticleStateful <: AbstractParticle\n\nRepresentation of a particle with a state. It has four fields:\n\ndir::ParticleDirection: The direction of the particle, Incoming() or Outgoing().\nspecies::AbstractParticleType: The species of the particle, Electron(), Positron() etc.\nmom::AbstractFourMomentum: The momentum of the particle.\n\nOverloads for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are provided, delegating the call to the correct field and thus implementing the AbstractParticle interface.\n\njulia> using QEDcore\n\njulia> ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: incoming electron\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\njulia> ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: outgoing photon\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.PhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint\n\nRepresentation of a point in the phase space of a process. Contains the process (AbstractProcessDefinition), the model (AbstractModelDefinition), the phase space definition (AbstractPhasespaceDefinition), and stateful incoming and outgoing particles (ParticleStateful).\n\nThe legality of the combination of the given process and the incoming and outgoing particles is checked on construction. If the numbers of particles mismatch, the types of particles mismatch (note that order is important), or incoming particles have an Outgoing direction, an error is thrown.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> PhaseSpacePoint(\n            Compton(),\n            PerturbativeQED(),\n            PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n            (\n                ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Incoming(), Photon(), SFourMomentum(1, 0, 0, 0))\n            ),\n            (\n                ParticleStateful(Outgoing(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\n            )\n        )\nPhaseSpacePoint:\n    process: one-photon Compton scattering\n    model: perturbative QED\n    phasespace definition: spherical coordinates in electron rest frame\n    incoming particles:\n     -> incoming electron: [1.0, 0.0, 0.0, 0.0]\n     -> incoming photon: [1.0, 0.0, 0.0, 0.0]\n    outgoing particles:\n     -> outgoing electron: [1.0, 0.0, 0.0, 0.0]\n     -> outgoing photon: [1.0, 0.0, 0.0, 0.0]\n\nnote: Note\nPhaseSpacePoints can be constructed with only one of their in- or out-channel set. For this, see the special constructors InPhaseSpacePoint and OutPhaseSpacePoint. The InPhaseSpacePoint and OutPhaseSpacePoint type definitions can be used to dispatch on such PhaseSpacePoints. Note that a full PhaseSpacePoint containing both its in- and out-channel matches both, .i.e. psp isa InPhaseSpacePoint and psp isa OutPhaseSpacePoint both evaluate to true if psp contains both channels. A completely empty PhaseSpacePoint is not allowed.\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.InPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: OutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.OutPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: InPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#Accessors","page":"Phase Space Points","title":"Accessors","text":"","category":"section"},{"location":"library/phasespacepoint/","page":"Phase Space Points","title":"Phase Space Points","text":"getindex\n_momentum_type","category":"page"},{"location":"library/phasespacepoint/#Base.getindex","page":"Phase Space Points","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Incoming, n::Int)\n\nOverload for the array indexing operator []. Returns the nth incoming particle in this phase space point.\n\n\n\n\n\nBase.getindex(psp::PhaseSpacePoint, dir::Outgoing, n::Int)\n\nOverload for the array indexing operator []. Returns the nth outgoing particle in this phase space point.\n\n\n\n\n\n","category":"function"},{"location":"library/phasespacepoint/#QEDcore._momentum_type","page":"Phase Space Points","title":"QEDcore._momentum_type","text":"_momentum_type(psp::PhaseSpacePoint)\n_momentum_type(type::Type{PhaseSpacePoint})\n\nReturns the element type of the PhaseSpacePoint object or type, e.g. SFourMomentum.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> psp = PhaseSpacePoint(Compton(), PerturbativeQED(), PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()), Tuple(rand(SFourMomentum) for _ in 1:2), Tuple(rand(SFourMomentum) for _ in 1:2));\n\njulia> QEDcore._momentum_type(psp)\nSFourMomentum\n\njulia> QEDcore._momentum_type(typeof(psp))\nSFourMomentum\n\n\n\n\n\n","category":"function"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"particles.md\", \"phasespacedef.md\", \"phasespacepoint.md\", \"vectors.md\"]","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"EditURL = \"../tutorial/particles.jl\"","category":"page"},{"location":"generated/particles/#Particles-and-Phase-Space-Points","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"There are three layers of abstraction from particles to phase space points in the QEDjl project:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"QEDbase.AbstractParticleType: Base type for singleton particle type definitions. We also call these species.\nQEDbase.AbstractParticleStateful: Base type for particles with a direction and carrying a momentum.\nQEDbase.AbstractPhaseSpacePoint: Representation of a point in the phase space for a combination of an QEDbase.AbstractProcessDefinition, QEDbase.AbstractModelDefinition, and QEDbase.AbstractPhasespaceDefinition.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This manual is intended to showcase the basic usage of these types and their implementations in QEDcore.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"struct UnexpectedSuccess <: Exception end # hide\nusing QEDcore","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"To use concrete process definitions and models, we also need to use QEDprocesses.jl","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"using QEDprocesses","category":"page"},{"location":"generated/particles/#Particle-Types","page":"Particles and Phase Space Points","title":"Particle Types","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"QEDcore currently defines the three basic particle types of QED, Electron, Positron, and Photon, and a type hierarchy for them:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert Photon <: MajoranaBoson\n@assert Electron <: Fermion\n@assert Positron <: AntiFermion","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"All of these are subtypes of QEDbase.AbstractParticleType. There are also convenience functions in Julia convention:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert is_boson(Photon())\n@assert is_particle(Electron())\n@assert is_anti_particle(Positron())\n\n@assert !is_boson(Electron())\n@assert !is_anti_particle(Electron())\n@assert !is_fermion(Photon())","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"These functions are part of QEDbase.jl's particle interface.","category":"page"},{"location":"generated/particles/#ParticleStateful","page":"Particles and Phase Space Points","title":"ParticleStateful","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"ParticleStateful is the implementation of QEDbase's QEDbase.AbstractParticleStateful interface. It represents a particle with a direction (as used in the context of scattering processes, QEDbase.Incoming, QEDbase.Outgoing, or QEDbase.UnknownDirection), a particle species (Electron, Positron, Photon, ...), and a 4-momentum vector.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"ps = ParticleStateful(Incoming(), Electron(), rand(SFourMomentum))","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"The relevant accessor functions for the interface are implemented:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particle_direction(ps)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particle_species(ps)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"momentum(ps)","category":"page"},{"location":"generated/particles/#Phase-Space-Points","page":"Particles and Phase Space Points","title":"Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"A PhaseSpacePoint is the combination of incoming and outgoing ParticleStatefuls. It also contains information about the scattering process, model, and phase space that it is created for.","category":"page"},{"location":"generated/particles/#Constructors","page":"Particles and Phase Space Points","title":"Constructors","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),                      # scattering process\n    PerturbativeQED(),              # physics model\n    PhasespaceDefinition(           # phase space definition\n        SphericalCoordinateSystem(),# coordinate system\n        ElectronRestFrame(),        # frame of reference\n    ),\n    (   # momenta of the incoming particles\n        rand(SFourMomentum),\n        rand(SFourMomentum),\n    ),\n    (   # momenta of the outgoing particles\n        rand(SFourMomentum),\n        rand(SFourMomentum),\n    ),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This version of the constructor automatically creates ParticleStateful obejcts from the momenta, matching the particles of the process. In the case of Compton, this is means an incoming electron and photon, and outgoing electron and photon.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Automatic checks make sure that the number of 4-momenta given matches the necessary number of 4-momenta for the process (this adds 0 overhead at runtime because it is inferred from type information alone).","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"try # hide\n    PhaseSpacePoint(\n        Compton(),\n        PerturbativeQED(),\n        PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n        (rand(SFourMomentum),), # incorrect number of incoming momenta, should be 2\n        (rand(SFourMomentum), rand(SFourMomentum)),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Alternatively, a PhaseSpacePoint can also be constructed from already existing ParticleStateful objects.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),                      # scattering process\n    PerturbativeQED(),              # physics model\n    PhasespaceDefinition(           # phase space definition\n        SphericalCoordinateSystem(),# coordinate system\n        ElectronRestFrame(),        # frame of reference\n    ),\n    (   # incoming particles\n        ParticleStateful(Incoming(), Electron(), rand(SFourMomentum)),\n        ParticleStateful(Incoming(), Photon(), rand(SFourMomentum)),\n    ),\n    (   # outgoing particles\n        ParticleStateful(Outgoing(), Electron(), rand(SFourMomentum)),\n        ParticleStateful(Outgoing(), Photon(), rand(SFourMomentum)),\n    ),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Similar to the constructor from momenta, this checks that the given ParticleStatefuls fit to the given process and throws otherwise. Again, since this can be infered from type information alone, it adds no overhead.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"try # hide\n    PhaseSpacePoint(\n        Compton(),\n        PerturbativeQED(),\n        PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n        (   # incoming particles\n            ParticleStateful(Incoming(), Positron(), rand(SFourMomentum)), # incorrect particle type\n            ParticleStateful(Incoming(), Photon(), rand(SFourMomentum)),\n        ),\n        (   # outgoing particles\n            ParticleStateful(Outgoing(), Electron(), rand(SFourMomentum)),\n            ParticleStateful(Outgoing(), Photon(), rand(SFourMomentum)),\n        ),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nWhile these constructors check that the given types make sense and work together, they do not check whether the given momenta make a physical phase space point or that the incoming or outgoing particles have on-shell 4-momenta.","category":"page"},{"location":"generated/particles/#Accessors","page":"Particles and Phase Space Points","title":"Accessors","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"The phase space point provides some convenient accessors to the stateful particles within:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp[Incoming(), 1]  # the first incoming particle","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp[Outgoing(), 2]  # the second outgoing particle","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"particles(psp, Incoming()) # all incoming particles as a tuple","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Momentum accessors:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"momentum(psp, Incoming(), Electron(), 1) # the momentum of the first incoming electron","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"When only one particle of the species exists in the particle set, the 1 can be ommitted for convenience.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"@assert ans == momentum(psp, Incoming(), Electron())","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nThis method throws when multiple (or zero) particles of the given direction and species exist in the phase space point.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"When the index of the required momentum is known at compile time, a Val(N) can be used instead of N. This performs bounds checks at compile time and removes loops from the runtime execution","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"using BenchmarkTools\njudge(\n    median(@benchmark momentum($psp, Incoming(), Photon(), Val(1))),\n    median(@benchmark momentum($psp, Incoming(), Photon(), 1)),\n)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"note: Note\nThis is only faster when N is actually known at compile time, for example when it is a literal integer or a function's type parameter. For dynamic values of N, prefer the Int variant or in case of loops, directly loop over the tuple of momenta.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Some more overloads for the momentum function exist, for a complete list please refer to its documentation: QEDbase.momentum, QEDbase.momenta.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Finally, process, model, and phase_space_definition can be used to request the object in question:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"process(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"model(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"phase_space_definition(psp)","category":"page"},{"location":"generated/particles/#In/Out-Phase-Space-Points","page":"Particles and Phase Space Points","title":"In/Out Phase Space Points","text":"","category":"section"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"As a special case, phase space points are allowed to only contain the incoming or outgoing particle momenta. These types can be helpful for overloading some functions that don't require the entire phase space point to exist.","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"function in_sum(in_psp::AbstractInPhaseSpacePoint)\n    return sum(momenta(in_psp, Incoming()))\nend\n\npsp = InPhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\nin_sum(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"Every full PhaseSpacePoint is both an InPhaseSpacePoint and an OutPhaseSpacePoint, too. For example, the in_sum function defined above still works with a full PhaseSpacePoint:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = PhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\nin_sum(psp)","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"But an InPhaseSpacePoint is not an OutPhaseSpacePoint and vice versa. We cannot call in_sum on an OutPhaseSpacePoint:","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"psp = OutPhaseSpacePoint(\n    Compton(),\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    (rand(SFourMomentum), rand(SFourMomentum)),\n)\n\ntry # hide\n    in_sum(psp)\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"","category":"page"},{"location":"generated/particles/","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"EditURL = \"../tutorial/ps_def.jl\"","category":"page"},{"location":"generated/ps_def/#Phase-Space-Definition","page":"Phase Space Definitions","title":"Phase Space Definition","text":"","category":"section"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"note: Note\nPhasespaceDefinitions are to be reworked (see this issue). Therefore, this manual is very rudimentary for the moment.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"A PhasespaceDefinition is a representation of a phase space's layout. It is a singleton type definition and has an AbstractCoordinateSystem and an AbstractFrameOfReference.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"using QEDcore\nps_def = PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame())","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"The phase space definition is used in PhaseSpacePoints for dispatching in some of the cross-section interface functions.","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"","category":"page"},{"location":"generated/ps_def/","page":"Phase Space Definitions","title":"Phase Space Definitions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/lorentzboosts/#Lorentz-Boosts","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"","category":"section"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"The following is an implementation of the Lorentz Boost Interface of QEDbase.jl.","category":"page"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/lorentzboosts/","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"Boost\nBetaVector\nBetaX\nBetaY\nBetaZ\nAbstractCoordinateTransformation","category":"page"},{"location":"library/lorentzboosts/#QEDcore.Boost","page":"Lorentz Boosts","title":"QEDcore.Boost","text":"Boost{V<:AbstractBoostParameter} <: AbstractLorentzBoost\n\nA concrete type representing a Lorentz boost transformation, parameterized by a boost parameter V. The boost parameter can be either axis-specific or vector-like, depending on the subtype of AbstractBoostParameter used. The Boost type is used to perform Lorentz boosts on four-vectors (such as four-momentum or four-position) between different inertial frames in special relativity.\n\nFields\n\nparam::V: A boost parameter of type V, which is a subtype of AbstractBoostParameter.   This parameter defines the velocity (as a fraction of the speed of light, beta)   and the direction of the boost (e.g., along a single axis or in multiple directions).\n\nOverview\n\nA Lorentz boost is a transformation that adjusts the time and spatial components of a four-vector based on the relative velocity between two reference frames. The Boost struct provides a general and flexible implementation of such a boost, where the type of the boost parameter determines the direction and magnitude of the boost.\n\nDepending on the boost parameter V, the boost can be:\n\nAxis-specific: When V is an axis-specific boost parameter (e.g., BetaX), the   boost will be along that axis.\nVector-like: When V is a vector of boost parameters (e.g., BetaVector), the   boost will have components in multiple spatial directions.\n\nExample\n\nTo create a Lorentz boost along the x-axis using the BetaX boost parameter:\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost_x = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\nTo perform a Lorentz boost using the boost_x object, you can apply it to a four-vector, such as four-momentum:\n\njulia> p = SFourMomentum(4, 3, 2, 1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost_x(p)  # Perform the boost\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p, p_prime*p_prime)  # The invariant mass is preserved\n\nNotes\n\nThe Boost type provides a unified and flexible interface for applying Lorentz boosts, with the boost parameter V determining the specific form of the transformation. Lorentz boosts preserve the spacetime interval, meaning that applying the boost to a four-vector will not change the invariant quantity.\n\nSee Also\n\nAbstractBoostParameter: Base type for specific kinds of boost parameters.\nBetaX: Boost parameter for the x-axis.\nBetaY: Boost parameter for the y-axis.\nBetaZ: Boost parameter for the z-axis.\nBetaVector: Vector of boost parameters for boosts in multiple spatial directions.\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaVector","page":"Lorentz Boosts","title":"QEDcore.BetaVector","text":"BetaVector(x::Real,y::Real,z::Real)\n\nRepresents the spatial vector of velocity parameters (denoted as the \"beta\" vector) associated with motion in the three Cartesian directions, i.e., vecbeta = (beta_x beta_y beta_z). These components correspond to the velocity of an object (in units of the speed of light) in each of the x, y, and z directions.\n\nThe Lorentz boost along the direction of the beta vector vecbeta transforms the four-momentum as follows:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\n    gamma  (p_0 - vecbeta vec p)\np_1 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_x\np_2 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_y\n    p_3 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_z\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2.\n\nExample\n\njulia> using QEDcore\n\njulia> beta_vec = BetaVector(0.2,0.3,0.1)\nBetaVector{Float64}(0.2, 0.3, 0.1)\n\njulia> boost = Boost(beta_vec)\nBoost{BetaVector{Float64}}(BetaVector{Float64}(0.2, 0.3, 0.1))\n\njulia> p = SFourMomentum(4.0,3.0,2.0,1.0)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.911484876492837\n 2.282803602436349\n 0.9242054036545237\n 0.6414018012181746\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\nROOT::Math:Boost from ROOT\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaX","page":"Lorentz Boosts","title":"QEDcore.BetaX","text":"BetaX(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the x-axis, commonly denoted as beta_x.\n\nThe transformation for a boost along the x-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_x p_1)\ngamma (p_1 - beta_x p_0)\np_2\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2)\n\nExample\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaY","page":"Lorentz Boosts","title":"QEDcore.BetaY","text":"BetaY(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the y-axis, commonly denoted as beta_y.\n\nThe transformation for a boost along the y-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_y p_2)\np_1\ngamma (p_2 - beta_y p_0)\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_y^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_y = BetaY(0.5)\nBetaY{Float64}(0.5)\n\njulia> boost = Boost(beta_y)\nBoost{BetaY{Float64}}(BetaY{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n 3.4641016151377553\n 3.0\n 0.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaZ","page":"Lorentz Boosts","title":"QEDcore.BetaZ","text":"BetaZ(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the z-axis, commonly denoted as beta_z.\n\nThe transformation for a boost along the z-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_z p_3)\np_1\np_2\ngamma (p_3 - beta_z p_0)\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_z^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_z = BetaZ(0.5)\nBetaZ{Float64}(0.5)\n\njulia> boost = Boost(beta_z)\nBoost{BetaZ{Float64}}(BetaZ{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum with indices SOneTo(4):\n  4.041451884327381\n  3.0\n  2.0\n -1.1547005383792517\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.AbstractCoordinateTransformation","page":"Lorentz Boosts","title":"QEDcore.AbstractCoordinateTransformation","text":"AbstractCoordinateTransformation\n\nAbstract base type for coordinate transformations supposed to be acting on four-momenta. Every subtype of trafo::AbstractCoordinateTransformation should implement the following interface functions:\n\nQEDcore._transform(trafo,p): transforms p\nBase.inv(trafo): returns the inverted transform\n\nExample\n\nImplementing the interface by defining the interface functions:\n\njulia> using QEDcore\n\njulia> struct TestTrafo{T} <: QEDcore.AbstractCoordinateTransformation\n           a::T\n       end\n\njulia> QEDcore._transform(trafo::TestTrafo,p) = trafo.a*p\n\njulia> Base.inv(trafo::TestTrafo) = TestTrafo(inv(trafo.a))\n\n\nThe TestTrafo can then be used to transform four-momenta:\n\njulia> trafo = TestTrafo(2.0)\nTestTrafo{Float64}(2.0)\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> trafo(p) # multiply every component with 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 8.0\n 6.0\n 4.0\n 2.0\n\njulia> inv(trafo)(p) # divide every component by 2.0\n4-element SFourMomentum with indices SOneTo(4):\n 2.0\n 1.5\n 1.0\n 0.5\n\n\n\n\n\n","category":"type"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"EditURL = \"../tutorial/vectors.jl\"","category":"page"},{"location":"generated/vectors/#Vector-and-Matrix-Types","page":"Matrix and Vector Types","title":"Vector and Matrix Types","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"TBW","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"using QEDcore","category":"page"},{"location":"generated/vectors/#Lorentz-Vectors","page":"Matrix and Vector Types","title":"Lorentz Vectors","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"lv = rand(SLorentzVector)","category":"page"},{"location":"generated/vectors/#Bispinors-and-Adjoint-Bispinors","page":"Matrix and Vector Types","title":"Bispinors and Adjoint Bispinors","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"bs = rand(BiSpinor)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs = rand(AdjointBiSpinor)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs * bs","category":"page"},{"location":"generated/vectors/#Dirac-and-Gamma-Matrices","page":"Matrix and Vector Types","title":"Dirac and Gamma Matrices","text":"","category":"section"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"gm = rand(DiracMatrix)","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"abs * gm * bs","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"","category":"page"},{"location":"generated/vectors/","page":"Matrix and Vector Types","title":"Matrix and Vector Types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/vectors/#Vector-and-Matrix-Types","page":"Vector Types","title":"Vector and Matrix Types","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/vectors/#4-Momenta","page":"Vector Types","title":"4-Momenta","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"SFourMomentum\nMFourMomentum","category":"page"},{"location":"library/vectors/#QEDcore.SFourMomentum","page":"Vector Types","title":"QEDcore.SFourMomentum","text":"struct SFourMomentum <: AbstractFourMomentum\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.MFourMomentum","page":"Vector Types","title":"QEDcore.MFourMomentum","text":"mutable struct MFourMomentum <: AbstractFourMomentum\n\nBuilds a mutable LorentzVector with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Float64: energy component\npx::Float64: x component\npy::Float64: y component\npz::Float64: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Spinors","page":"Vector Types","title":"Spinors","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"BiSpinor\nAdjointBiSpinor","category":"page"},{"location":"library/vectors/#QEDcore.BiSpinor","page":"Vector Types","title":"QEDcore.BiSpinor","text":"struct BiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model a Dirac four-spinor with complex-valued components. These are the elements of an actual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.AdjointBiSpinor","page":"Vector Types","title":"QEDcore.AdjointBiSpinor","text":"struct AdjointBiSpinor <: AbstractDiracVector{ComplexF64}\n\nConcrete type to model an adjoint Dirac four-spinor with complex-valued components. These are the elements of the dual spinor space.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Lorentz-Vectors","page":"Vector Types","title":"Lorentz Vectors","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"SLorentzVector\nMLorentzVector","category":"page"},{"location":"library/vectors/#QEDcore.SLorentzVector","page":"Vector Types","title":"QEDcore.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.MLorentzVector","page":"Vector Types","title":"QEDcore.MLorentzVector","text":"mutable struct MLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic mutable Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Dirac-Matrix","page":"Vector Types","title":"Dirac Matrix","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"DiracMatrix","category":"page"},{"location":"library/vectors/#QEDcore.DiracMatrix","page":"Vector Types","title":"QEDcore.DiracMatrix","text":"struct DiracMatrix <: AbstractDiracMatrix{ComplexF64}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#Multiplications","page":"Vector Types","title":"Multiplications","text":"","category":"section"},{"location":"library/vectors/","page":"Vector Types","title":"Vector Types","text":"_mul","category":"page"},{"location":"library/vectors/#QEDcore._mul","page":"Vector Types","title":"QEDcore._mul","text":"_mul(aBS::AdjointBiSpinor, BS::BiSpinor) -> ComplexF64\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(BS::BiSpinor, aBS::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(DM::DiracMatrix, BS::BiSpinor) -> BiSpinor\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix\n) -> AdjointBiSpinor\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(DM1::DiracMatrix, DM2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(\n    aBS::AdjointBiSpinor,\n    DM::DiracMatrix,\n    BS::BiSpinor\n) -> ComplexF64\n\n\nTensor product of Dirac matrix sandwiched between an adjoint and a standard bi-spinor resulting in a scalar.\n\n\n\n\n\n","category":"function"},{"location":"library/phasespacedef/#Phase-Space-Definitions","page":"Phase Space Definition","title":"Phase Space Definitions","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"CurrentModule = QEDcore","category":"page"},{"location":"library/phasespacedef/#Phase-Space-Definition-Type","page":"Phase Space Definition","title":"Phase Space Definition Type","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"PhasespaceDefinition","category":"page"},{"location":"library/phasespacedef/#QEDcore.PhasespaceDefinition","page":"Phase Space Definition","title":"QEDcore.PhasespaceDefinition","text":"PhasespaceDefinition(coord_sys::AbstractCoordinateSystem, frame::AbstractFrameOfReference)\n\nConvenient type to dispatch on coordiante systems and frames of reference. Combines a AbstractCoordinateSystem with a AbstractFrameOfReference.\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#Frames-of-Reference","page":"Phase Space Definition","title":"Frames of Reference","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"CenterOfMomentumFrame\nElectronRestFrame","category":"page"},{"location":"library/phasespacedef/#QEDcore.CenterOfMomentumFrame","page":"Phase Space Definition","title":"QEDcore.CenterOfMomentumFrame","text":"CenterOfMomentumFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#QEDcore.ElectronRestFrame","page":"Phase Space Definition","title":"QEDcore.ElectronRestFrame","text":"ElectronRestFrame <: AbstractFrameOfReference\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacedef/#Coordinate-Systems","page":"Phase Space Definition","title":"Coordinate Systems","text":"","category":"section"},{"location":"library/phasespacedef/","page":"Phase Space Definition","title":"Phase Space Definition","text":"SphericalCoordinateSystem","category":"page"},{"location":"library/phasespacedef/#QEDcore.SphericalCoordinateSystem","page":"Phase Space Definition","title":"QEDcore.SphericalCoordinateSystem","text":"SphericalCoordinateSystem <: AbstractCoordinateSystem\n\nTBW\n\n\n\n\n\n","category":"type"},{"location":"#QEDcore.jl","page":"Home","title":"QEDcore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is part of the QuantumElectrodynamics.jl library. For the description of the interoperability with other packages of QuantumElectrodynamics.jl see docs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package's main purpose is to provide implementations of the basic interfaces defined in QEDbase.jl, such as various particle types, PhasespaceDefinition, PhaseSpacePoint, and various vector and matrix types. These types are used across most of the QEDjl-project repositories. For detailed information on these types, please refer to the respective pages in the docs.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! If you'd like to report a bug, suggest an enhancement, or contribute code, please feel free to open an issue or submit a pull request.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure consistency across the QuantumElectrodynamics.jl ecosystem, we encourage all contributors to review the QuantumElectrodynamics.jl contribution guide.","category":"page"},{"location":"#Credits-and-contributors","page":"Home","title":"Credits and contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core code of the package QEDcore.jl is developed by a small team at the Center for Advanced Systems Understanding (CASUS), namely","category":"page"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uwe Hernandez Acosta (CASUS/HZDR, u.hernandez@hzdr.de)\nAnton Reinhard (CASUS/HZDR)\nSimeon Ehrig (CASUS/HZDR)","category":"page"},{"location":"#Former-Contributors","page":"Home","title":"Former Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We extend our sincere thanks to all contributors who have supported this project.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT © Uwe Hernandez Acosta","category":"page"}]
}
