var documenterSearchIndex = {"docs":
[{"location":"library/phase_space_layout/#Phase-Space-Layout","page":"Phase Space Layout","title":"Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/#Coordinate-Maps","page":"Phase Space Layout","title":"Coordinate Maps","text":"","category":"section"},{"location":"library/phase_space_layout/#Implementations","page":"Phase Space Layout","title":"Implementations","text":"","category":"section"},{"location":"library/phase_space_layout/#Two-body-Phase-Space-Layout","page":"Phase Space Layout","title":"Two-body Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/#Flat-Phase-Space-Layout","page":"Phase Space Layout","title":"Flat Phase Space Layout","text":"","category":"section"},{"location":"library/phase_space_layout/#QEDcore.CoordinateMap","page":"Phase Space Layout","title":"QEDcore.CoordinateMap","text":"CoordinateMap{P,M,PSL}(proc::P, model::M, psl::PSL)\n\nA CoordinateMap represents a transformation that maps phase space coordinates to particle momenta for a specific scattering process. This type encapsulates the scattering process definition (proc), the physics model (model), and the phase space layout (psl). The CoordinateMap is callable and supports the conversion of both incoming and outgoing phase space coordinates into four-momenta.\n\nFields\n\nproc: The scattering process definition, subtype of AbstractProcessDefinition.\nmodel: The physics model, subtype of AbstractModelDefinition.\npsl: The phase space layout, either incoming or outgoing, that maps coordinates to momenta.\n\nUsage\n\nIncoming Coordinates\n\nThe CoordinateMap can be called with a tuple of incoming phase space coordinates (in_coords), which are used to compute the corresponding incoming particle four-momenta. This is done by calling the phase space construction function QEDbase.build_momenta using the proc, model, and psl provided in the CoordinateMap.\n\n# Create a coordinate map for in phase space\nin_coord_map = CoordinateMap(proc, model, in_psl)\n\n# call on in-coordinates to build the momenta\nin_coord_map(in_coords)\n\nArguments:\nin_coords: A tuple of phase space coordinates for the incoming particles.\nReturns: A tuple of four-momenta corresponding to the incoming particles.\n\nIncoming and Outgoing Coordinates\n\nThe CoordinateMap can also be called with both incoming (in_coords) and outgoing (out_coords) phase space coordinates. The incoming momenta are computed first, and then the total momentum (Ptot) is calculated by summing these momenta. This total momentum is then used to compute the outgoing particle four-momenta using the provided outgoing phase space layout.\n\n# Create a coordinate map for out phase space\ncoord_map = CoordinateMap(proc, model, out_psl)\n\n# call on in- and out-coordinates to build the momenta\ncoord_map(in_coords, out_coords)\n\nArguments:\nin_coords: A tuple of phase space coordinates for the incoming particles.\nout_coords: A tuple of phase space coordinates for the outgoing particles.\nReturns:\nA tuple where the first element is the incoming particle momenta and the second element   is the outgoing particle momenta, both represented as tuples of four-momenta.\n\nNotes\n\nThe CoordinateMap provides a flexible mechanism for transforming phase space coordinates   into physically meaningful four-momenta, ensuring consistency with the scattering process,   physics model, and phase space layout.\nThe type is designed to handle both incoming and outgoing momenta, ensuring proper energy   and momentum conservation for the process.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.CoordinateMapCached","page":"Phase Space Layout","title":"QEDcore.CoordinateMapCached","text":"CoordinateMapCached{P,M,PSL,TM}(proc::P, model::M, psl::PSL, in_moms::TM)\n\nA CoordinateMapCached represents a precomputed transformation for phase space coordinates, where the momenta of the incoming particles are cached. This can improve performance in cases where the incoming momenta remain constant and only the outgoing momenta need to be computed based on new coordinates.\n\nThe cached map encapsulates the scattering process (proc), the physics model (model), the phase space layout (psl), and the precomputed incoming momenta (in_moms).\n\nFields\n\nproc: The scattering process definition, which defines the incoming and outgoing particles.\nmodel: The physics model, which governs the interaction type and momentum distributions.\npsl: The phase space layout, either incoming or outgoing, that maps coordinates to momenta.\nin_moms: A collection of precomputed four-momenta for the incoming particles, usually a Tuple.\n\nUsage\n\nCached Incoming Coordinates\n\nWhen a CoordinateMapCached build with psl::AbstractInPhaseSpaceLayout is called without any arguments, it returns the precomputed incoming momenta (in_moms) directly. This provides an efficient way to access the incoming particle momenta that have already been calculated and stored in the map.\n\n# Create a coordinate map for in phase space\nin_coord_map = CoordinateMapCached(proc, model, in_psl, in_moms)\n\n# call to return the in-momenta\nin_coord_map()\n\nReturns: The cached tuple of four-momenta for the incoming particles.\n\nOutgoing Coordinates\n\nThe CoordinateMapCached can be called with outgoing phase space coordinates (out_coords). The cached incoming momenta (in_moms) are used to compute the total momentum (Ptot), which is then passed along with the outgoing coordinates to compute the momenta of the outgoing particles.\n\n# Create a coordinate map for out phase space\nout_coord_map = CoordinateMapCached(proc, model, out_psl, in_moms)\n\n# call on out coordinates to return the out-momenta\nout_coord_map(out_coords)\n\nArguments:\nout_coords: A tuple of phase space coordinates for the outgoing particles.\nReturns:\nA tuple of four-momenta for the outgoing particles, consistent with the total momentum   derived from the cached incoming momenta.\n\nNotes\n\nCaching: The CoordinateMapCached is useful when the incoming momenta are fixed or do   not change frequently, as it avoids recomputation by storing the incoming momenta in the   cache.\nEfficiency: This caching mechanism can significantly enhance performance when repeatedly   evaluating the scattering process with fixed incoming particles but varying outgoing   configurations.\nThe type is designed to handle both incoming and outgoing momenta, ensuring proper energy   and momentum conservation for the process.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.AbstractTwoBodyInPhaseSpaceLayout","page":"Phase Space Layout","title":"QEDcore.AbstractTwoBodyInPhaseSpaceLayout","text":"AbstractTwoBodyInPhaseSpaceLayout <: AbstractInPhaseSpaceLayout\n\nAn abstract type representing an incoming phase space layout specifically designed for two-body systems in high-energy physics. This type is a specialized subtype of AbstractInPhaseSpaceLayout, focusing on scenarios where two particles are incoming and participate in a scattering or decay process.\n\nConcrete subtypes of AbstractTwoBodyInPhaseSpaceLayout define the parameterization of the momenta of the two incoming particles, such as by Energy, Rapidity, or other kinematic coordinates. These layouts allow for consistent calculation of the system's phase-space properties under conservation laws, facilitating method dispatch in functions like QEDbase._build_momenta.\n\nThis type serves as a foundation for implementing concrete layouts, ensuring that two-body processes can be modeled flexibly and accurately within phase space calculations.\n\nSee Also\n\nQEDbase.AbstractInPhaseSpaceLayout: A broader type for general incoming phase space layouts.\nAbstractTwoBodyRestSystem: A subtype representing two-body systems where one   particle is at rest.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.AbstractTwoBodyRestSystem","page":"Phase Space Layout","title":"QEDcore.AbstractTwoBodyRestSystem","text":"AbstractTwoBodyRestSystem <: AbstractTwoBodyInPhaseSpaceLayout\n\nAn abstract type representing the phase space layout of a two-body system in which one particle is at rest in the system's frame.\n\nConcrete subtypes of AbstractTwoBodyRestSystem typically specify the coordinate system used to parameterize the momentum of the non-resting particle, such as Energy, SpatialMagnitude, CenterOfMomentumEnergy, or Rapidity. The choice of coordinate system impacts how the momenta of the incoming particles are constructed.\n\nThis type serves as a base for defining custom layouts that rely on rest-frame assumptions for two-body scattering or decay processes, and it facilitates method dispatch in momentum construction functions like QEDbase._build_momenta.\n\nSee Also\n\nTwoBodyRestSystem: A concrete implementation of AbstractTwoBodyRestSystem that   supports various univariate coordinates for describing the non-resting particle.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.TwoBodyRestSystem","page":"Phase Space Layout","title":"QEDcore.TwoBodyRestSystem","text":"TwoBodyRestSystem{RESTIDX, COORD<:AbstractUnivariateCoordinate}\n\nRepresents a two-body scattering system in the rest frame of one of the particles, where one particle (identified by RESTIDX) is at rest and the other particle's momentum is described by a coordinate system COORD. The system uses various univariate coordinates, such as energy, rapidity, or center-of-momentum energy, to parameterize the momentum of the moving particle.\n\nThis type allows for easy construction of the incoming particle momenta using the phase space layout for two-body systems, commonly used in high-energy physics processes. The system supports different coordinate systems for defining the moving particle's momenta, including energy-based and rapidity-based layouts.\n\nFields\n\ncoord::COORD: The coordinate type (COORD) used to describe the non-resting particle's momenta.\n\nSupported Coordinates\n\nEnergy: Defines the energy of the moving particle.\nSpatialMagnitude: Defines the spatial momentum magnitude of the moving particle.\nCMSEnergy: Defines the total center-of-mass energy of the system.\nRapidity: Defines the rapidity of the moving particle.\n\nExample Usages\n\nThe following examples show how to use different coordinate systems with TwoBodyRestSystem in conjunction with the _build_momenta interface.\n\nExample 1: Using Energy Coordinate\n\npsl = TwoBodyRestSystem(Energy(2))  # Particle 1 at rest, particle 2 described by its energy\nin_coords = (100.0,)  # Energy of particle 2\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nThis constructs the momenta assuming particle 1 is at rest, and particle 2 has an energy of 100 GeV.\n\nExample 2: Using SpatialMagnitude Coordinate\n\npsl = TwoBodyRestSystem(SpatialMagnitude(2))  # Particle 1 at rest, particle 2 described by its spatial magnitude\nin_coords = (50.0,)  # Spatial momentum magnitude of particle 2\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nIn this case, the moving particle's spatial momentum magnitude is given, and its energy is calculated based on its mass.\n\nExample 3: Using CMSEnergy Coordinate\n\npsl = TwoBodyRestSystem(1,CMSEnergy())  # Particle 1 at rest, particle 2 described by the center-of-mass energy\nin_coords = (200.0,)  # Total center-of-mass energy of the system\nmomenta = build_momenta(proc, model, psl, in_coords)\n\nHere, the center-of-mass energy of the system is provided, and the momenta of both particles are calculated while conserving energy and momentum.\n\nExample 4: Using Rapidity Coordinate\n\npsl = TwoBodyRestSystem(Rapidity(2))  # Particle 1 at rest, particle 2 described by its rapidity\nin_coords = (1.0,)  # Rapidity of particle 2\nmomenta = _build_momenta(proc, model, psl, in_coords)\n@assert isapprox(getMass(sum(momenta)),50.0)\n\nIn this case, the rapidity of particle 2 is given, and its energy and momentum are computed based on this parameter.\n\nNotes\n\nRESTIDX is the index of the particle that is at rest in the system.\nCOORD specifies the coordinate type of the non-resting particle and must be a subtype of   AbstractUnivariateCoordinate.\nThe coordinate system should be compatible with the given particles and their masses,   otherwise, an error may occur during momentum construction.\n\nThrows\n\nArgumentError if invalid coordinates are used (e.g., unsupported coordinate types or   incompatible indices).\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore.FlatPhaseSpaceLayout","page":"Phase Space Layout","title":"QEDcore.FlatPhaseSpaceLayout","text":"FlatPhaseSpaceLayout{INPSL} <: QEDbase.AbstractOutPhaseSpaceLayout{INPSL}\n\nDefines a flat phase space layout for generating outgoing particle momenta. This layout assumes that outgoing particles are uniformly distributed in phase space, subject to constraints on momentum and energy conservation. This is accomplished by exploiting the RAMBO [2] (Random Momenta Beautifully Organized) algorithm to generate the momenta, supporting both massless and massive particles.\n\nFields\n\nin_psl::INPSL: Input phase space layout, which provides the initial state layout for the process. This field links to the input configuration, making it accessible for consistency across related calculations.\n\nUsage\n\nFlatPhaseSpaceLayout is commonly used in high-energy physics to define phase space configurations for event generators and cross-section calculations. Key functions include:\n\nQEDbase.phase_space_dimension: Calculates the phase space dimension based on the number of outgoing particles.\nQEDbase._build_momenta: Constructs the outgoing momenta using the provided phase space layout and RAMBO-based algorithms, ensuring the momenta satisfy energy and momentum conservation laws.\n\nExample\n\n# Define input and process information, model, and input coordinates\npsl = FlatPhaseSpaceLayout(input_psl)\nbuild_momenta(process, model, incoming_momenta, psl, out_coords)\n\nFlatPhaseSpaceLayout provides a robust setup for defining the final-state phase space in particle physics simulations, allowing for modularity and compatibility with QEDbase routines.\n\n\n\n\n\n","category":"type"},{"location":"library/phase_space_layout/#QEDcore._massive_rambo_moms","page":"Phase Space Layout","title":"QEDcore._massive_rambo_moms","text":"massiverambo_moms(c::Tuple, ss::Float64, masses::Tuple)\n\nComputes the massive outgoing momenta using RAMBO for given coordinates, center-of-momentum energy, and particle masses.\n\nArguments\n\nc::Tuple: Tuple of uniformly distributed coordinates.\nss::Float64: Center-of-momentum energy.\nmasses::Tuple Vector of particle masses for each outgoing particle.\n\nReturns\n\nA tuple of four-momenta for outgoing particles.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDcore._find_scaling_factor","page":"Phase Space Layout","title":"QEDcore._find_scaling_factor","text":"_find_scaling_factor(masses::Tuple, energies::Tuple, ss::Float64)\n\nFinds a scaling factor for particle momenta to enforce conservation of energy-momentum in massive RAMBO.\n\nArguments\n\nmasses::Tuple: Vector of outgoing particle masses.\nenergies::Tuple: Vector of outgoing particle energies.\nss::Float64: Center-of-momentum energy.\n\nReturns\n\nThe computed scaling factor as a float.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDcore._single_rambo_mom","page":"Phase Space Layout","title":"QEDcore._single_rambo_mom","text":"_single_rambo_mom(single_coords::Tuple)\n\nGenerates the four-momentum of a single particle from uniformly distributed coordinates. Assumes massless particle as an intermediate step in RAMBO.\n\nArguments\n\nsingle_coords::Tuple: Tuple of coordinates used to generate the particle's momentum.\n\nReturns\n\nA four-momentum (SFourMomentum) for a single particle.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDcore._tuple_partition_by_four","page":"Phase Space Layout","title":"QEDcore._tuple_partition_by_four","text":"_tuple_partition_by_four(c::Tuple)\n\nPartitions a tuple of coordinates by four, generating sub-tuples of four values each without allocating memory and in a type stable way. Currently overloaded for tuples of lengths 4..40.\n\nArguments\n\nc::Tuple: Tuple of coordinates.\n\nReturns\n\nNTuple containing four-element tuples.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDcore._unconserved_momenta","page":"Phase Space Layout","title":"QEDcore._unconserved_momenta","text":"_unconserved_momenta(c::Tuple)\n\nBuilds an initial set of momenta from uniform coordinates that do not necessarily conserve energy-momentum.\n\nArguments\n\nc::Tuple: Tuple of uniformly distributed coordinates.\n\nReturns\n\nTuple of four-momenta representing unconserved momenta.\n\n\n\n\n\n","category":"function"},{"location":"library/phase_space_layout/#QEDcore._massless_rambo_moms","page":"Phase Space Layout","title":"QEDcore._massless_rambo_moms","text":"_massless_rambo_moms(c::Tuple, ss::Float64)\n\nGenerates a set of massless momenta based on uniformly distributed coordinates. Ensures energy-momentum conservation.\n\nArguments\n\nc::Tuple: Tuple of uniformly distributed coordinates.\nss::Float64: Center-of-momentum energy.\n\nReturns\n\nTuple of massless four-momenta, which satisfy energy-momentum conservation.\n\n\n\n\n\n","category":"function"},{"location":"library/particles/#Particles","page":"Particles","title":"Particles","text":"","category":"section"},{"location":"library/particles/#Particle-Types","page":"Particles","title":"Particle Types","text":"The following are subtypes of QEDbase.AbstractParticleType(@extref).\n\nFor all these types the corresponding interface is implemented, including QEDbase.base_state(@extref) and QEDbase.propagator(@extref).","category":"section"},{"location":"library/particles/#QEDcore.FermionLike","page":"Particles","title":"QEDcore.FermionLike","text":"Abstract base types for particle species that act like fermions in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of FermionLike has is_fermion(::FermionLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.BosonLike","page":"Particles","title":"QEDcore.BosonLike","text":"Abstract base types for particle species that act like bosons in the sense of particle statistics.\n\nnote: particle interface\nEvery concrete subtype of BosonLike has is_boson(::BosonLike) = true.\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaFermion","page":"Particles","title":"QEDcore.MajoranaFermion","text":"Abstract base type for majorana-fermions, i.e. fermions which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaFermion haveis_fermion(::MajoranaFermion) = true\nis_particle(::MajoranaFermion) = true\nis_anti_particle(::MajoranaFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.MajoranaBoson","page":"Particles","title":"QEDcore.MajoranaBoson","text":"Abstract base type for majorana-bosons, i.e. bosons which are their own anti-particles.\n\nnote: particle interface\nAll subtypes of MajoranaBoson haveis_boson(::MajoranaBoson) = true\nis_particle(::MajoranaBoson) = true\nis_anti_particle(::MajoranaBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Fermion","page":"Particles","title":"QEDcore.Fermion","text":"Abstract base type for fermions as distinct from AntiFermions.\n\nnote: particle interface\nAll subtypes of Fermion haveis_fermion(::Fermion) = true\nis_particle(::Fermion) = true\nis_anti_particle(::Fermion) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Boson","page":"Particles","title":"QEDcore.Boson","text":"Abstract base type for bosons as distinct from its anti-particle counterpart AntiBoson.\n\nnote: particle interface\nAll subtypes of Boson haveis_boson(::Boson) = true\nis_particle(::Boson) = true\nis_anti_particle(::Boson) = false\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiFermion","page":"Particles","title":"QEDcore.AntiFermion","text":"Abstract base type for anti-fermions as distinct from its particle counterpart Fermion.\n\nnote: particle interface\nAll subtypes of AntiFermion haveis_fermion(::AntiFermion) = true\nis_particle(::AntiFermion) = false\nis_anti_particle(::AntiFermion) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.AntiBoson","page":"Particles","title":"QEDcore.AntiBoson","text":"Abstract base type for anti-bosons as distinct from its particle counterpart Boson.\n\nnote: particle interface\nAll subtypes of AntiBoson haveis_boson(::AntiBoson) = true\nis_particle(::AntiBoson) = false\nis_anti_particle(::AntiBoson) = true\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Electron","page":"Particles","title":"QEDcore.Electron","text":"Concrete type for electrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Electron()\nelectron\n\nnote: particle interface\nBesides being a subtype of Fermion, objects of type Electron havemass(::Type{T}, ::Electron) = one(T)\ncharge(::Type{T}, ::Electron) = -one(T)\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Positron","page":"Particles","title":"QEDcore.Positron","text":"Concrete type for positrons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Positron()\npositron\n\nnote: particle interface\nBesides being a subtype of AntiFermion, objects of type Positron havemass(::Type{T}, ::Positron) = one(T)\ncharge(::Type{T}, ::Positron) = one(T)\n\n\n\n\n\n","category":"type"},{"location":"library/particles/#QEDcore.Photon","page":"Particles","title":"QEDcore.Photon","text":"Concrete type for the photons as a particle species. Mostly used for dispatch.\n\njulia> using QEDcore\n\njulia> Photon()\nphoton\n\nnote: particle interface\nBesides being a subtype of MajoranaBoson, Photon hasmass(::Type{T}, ::Photon) = zero(T)\ncharge(::Type{T}, ::Photon) = zero(T)\n\n\n\n\n\n","category":"type"},{"location":"library/#QEDcore","page":"Index","title":"QEDcore","text":"API index for QEDcore.\n\n","category":"section"},{"location":"library/phasespacepoint/#Phase-Space-Points","page":"Phase Space Points","title":"Phase Space Points","text":"","category":"section"},{"location":"library/phasespacepoint/#Types-and-Aliases","page":"Phase Space Points","title":"Types and Aliases","text":"","category":"section"},{"location":"library/phasespacepoint/#Accessors","page":"Phase Space Points","title":"Accessors","text":"","category":"section"},{"location":"library/phasespacepoint/#QEDcore.ParticleStateful","page":"Phase Space Points","title":"QEDcore.ParticleStateful","text":"ParticleStateful <: AbstractParticle\n\nRepresentation of a particle with a state. It has four fields:\n\ndir::ParticleDirection: The direction of the particle, Incoming() or Outgoing().\nspecies::AbstractParticleType: The species of the particle, Electron(), Positron() etc.\nmom::AbstractFourMomentum: The momentum of the particle.\n\nOverloads for is_fermion, is_boson, is_particle, is_anti_particle, is_incoming, is_outgoing, mass, and charge are provided, delegating the call to the correct field and thus implementing the AbstractParticle interface.\n\njulia> using QEDcore\n\njulia> ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: incoming electron\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\njulia> ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\nParticleStateful: outgoing photon\n    momentum: [1.0, 0.0, 0.0, 0.0]\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.PhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.PhaseSpacePoint","text":"PhaseSpacePoint\n\nRepresentation of a point in the phase space of a process. Contains the process (AbstractProcessDefinition), the model (AbstractModelDefinition), the phase space layout (AbstractPhaseSpaceLayout), and stateful incoming and outgoing particles (AbstractParticleStateful).\n\nThe legality of the combination of the given process and the incoming and outgoing particles is checked on construction. If the numbers of particles mismatch, the types of particles mismatch (note that order is important), or incoming particles have an Outgoing direction, an error is thrown.\n\njulia> using QEDcore\n\njulia> using QEDbase.Mocks\n\njulia> PhaseSpacePoint(\n            MockProcess(),\n            MockModel(),\n            MockOutPhaseSpaceLayout(),\n            (\n                ParticleStateful(Incoming(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Incoming(), Photon(), SFourMomentum(1, 0, 0, 0))\n            ),\n            (\n                ParticleStateful(Outgoing(), Electron(), SFourMomentum(1, 0, 0, 0)),\n                ParticleStateful(Outgoing(), Photon(), SFourMomentum(1, 0, 0, 0))\n            )\n        )\nPhaseSpacePoint:\n    process: one-photon Compton scattering\n    model: perturbative QED\n    phasespace layout: default\n    incoming particles:\n     -> incoming electron: [1.0, 0.0, 0.0, 0.0]\n     -> incoming photon: [1.0, 0.0, 0.0, 0.0]\n    outgoing particles:\n     -> outgoing electron: [1.0, 0.0, 0.0, 0.0]\n     -> outgoing photon: [1.0, 0.0, 0.0, 0.0]\n\nnote: Note\nPhaseSpacePoints can be constructed with only one of their in- or out-channel set. For this, see the special constructors InPhaseSpacePoint and OutPhaseSpacePoint. The InPhaseSpacePoint and OutPhaseSpacePoint type definitions can be used to dispatch on such PhaseSpacePoints. Note that a full PhaseSpacePoint containing both its in- and out-channel matches both, .i.e. psp isa InPhaseSpacePoint and psp isa OutPhaseSpacePoint both evaluate to true if psp contains both channels. A completely empty PhaseSpacePoint is not allowed.\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.InPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.InPhaseSpacePoint","text":"InPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the in channel of the phase space to exist, for example implementations of _incident_flux. No restrictions are imposed on the out-channel, which may or may not exist.\n\nSee also: OutPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#QEDcore.OutPhaseSpacePoint","page":"Phase Space Points","title":"QEDcore.OutPhaseSpacePoint","text":"OutPhaseSpacePoint\n\nA partial type specialization on PhaseSpacePoint which can be used for dispatch in functions requiring only the out channel of the phase space to exist. No restrictions are imposed on the in-channel, which may or may not exist.\n\nSee also: InPhaseSpacePoint\n\n\n\n\n\n","category":"type"},{"location":"library/phasespacepoint/#Base.getindex","page":"Phase Space Points","title":"Base.getindex","text":"Base.getindex(psp::PhaseSpacePoint, dir::Incoming, n::Int)\n\nOverload for the array indexing operator []. Returns the nth incoming particle in this phase space point.\n\n\n\n\n\nBase.getindex(psp::PhaseSpacePoint, dir::Outgoing, n::Int)\n\nOverload for the array indexing operator []. Returns the nth outgoing particle in this phase space point.\n\n\n\n\n\n","category":"function"},{"location":"library/phasespacepoint/#QEDcore._momentum_type","page":"Phase Space Points","title":"QEDcore._momentum_type","text":"_momentum_type(psp::PhaseSpacePoint)\n_momentum_type(type::Type{PhaseSpacePoint})\n\nReturns the element type of the PhaseSpacePoint object or type, e.g. SFourMomentum.\n\njulia> using QEDcore; using QEDprocesses\n\njulia> psp = PhaseSpacePoint(Compton(), PerturbativeQED(), DefaultPhaseSpaceLayout(), Tuple(rand(SFourMomentum) for _ in 1:2), Tuple(rand(SFourMomentum) for _ in 1:2));\n\njulia> QEDcore._momentum_type(psp)\nSFourMomentum\n\njulia> QEDcore._momentum_type(typeof(psp))\nSFourMomentum\n\n\n\n\n\n","category":"function"},{"location":"library/outline/#API-Outline","page":"Contents","title":"API Outline","text":"Pages = [\"particles.md\", \"phasespacedef.md\", \"phasespacepoint.md\", \"vectors.md\"]","category":"section"},{"location":"generated/particles/#Particles-and-Phase-Space-Points","page":"Particles and Phase Space Points","title":"Particles and Phase Space Points","text":"There are three layers of abstraction from particles to phase space points in the QEDjl project:\n\nQEDbase.AbstractParticleType: Base type for singleton particle type definitions. We also call these species.\nQEDbase.AbstractParticleStateful: Base type for particles with a direction and carrying a momentum.\nQEDbase.AbstractPhaseSpacePoint: Representation of a point in the phase space for a combination of an QEDbase.AbstractProcessDefinition, QEDbase.AbstractModelDefinition, and QEDbase.AbstractPhaseSpaceLayout.\n\nThis manual is intended to showcase the basic usage of these types and their implementations in QEDcore.\n\nstruct UnexpectedSuccess <: Exception end # hide\nusing QEDcore\n\nTo use concrete process definitions, models and phase-space layouts, we use the QEDbase.Mocks module\n\nusing QEDbase.Mocks","category":"section"},{"location":"generated/particles/#Particle-Types","page":"Particles and Phase Space Points","title":"Particle Types","text":"QEDcore currently defines the three basic particle types of QED, Electron, Positron, and Photon, and a type hierarchy for them:\n\n@assert Photon <: MajoranaBoson\n@assert Electron <: Fermion\n@assert Positron <: AntiFermion\n\nAll of these are subtypes of QEDbase.AbstractParticleType. There are also convenience functions in Julia convention:\n\n@assert is_boson(Photon())\n@assert is_particle(Electron())\n@assert is_anti_particle(Positron())\n\n@assert !is_boson(Electron())\n@assert !is_anti_particle(Electron())\n@assert !is_fermion(Photon())\n\nThese functions are part of QEDbase.jl's particle interface.","category":"section"},{"location":"generated/particles/#ParticleStateful","page":"Particles and Phase Space Points","title":"ParticleStateful","text":"ParticleStateful is the implementation of QEDbase's QEDbase.AbstractParticleStateful interface. It represents a particle with a direction (as used in the context of scattering processes, QEDbase.Incoming, QEDbase.Outgoing, or QEDbase.UnknownDirection), a particle species (Electron, Positron, Photon, ...), and a 4-momentum vector.\n\nps = ParticleStateful(Incoming(), Electron(), rand(SFourMomentum))\n\nThe relevant accessor functions for the interface are implemented:\n\nparticle_direction(ps)\n\nparticle_species(ps)\n\nmomentum(ps)","category":"section"},{"location":"generated/particles/#Phase-Space-Points","page":"Particles and Phase Space Points","title":"Phase Space Points","text":"A PhaseSpacePoint is the combination of incoming and outgoing ParticleStatefuls. It also contains information about the scattering process, model, and phase space that it is created for.","category":"section"},{"location":"generated/particles/#Constructors","page":"Particles and Phase Space Points","title":"Constructors","text":"psp = PhaseSpacePoint(\n    MockProcess(                    # scattering process\n        (MockFermion(), MockBoson()),\n        (MockFermion(), MockBoson()),\n    ),\n    MockModel(),                    # physics model\n    MockOutPhaseSpaceLayout(        # layout for outgoing phase space\n        MockInPhaseSpaceLayout{     # layout for incoming phase space\n            MockMomentum,            # momentum type\n        }(),\n    ),\n    (   # momenta of the incoming particles\n        rand(MockMomentum),\n        rand(MockMomentum),\n    ),\n    (   # momenta of the outgoing particles\n        rand(MockMomentum),\n        rand(MockMomentum),\n    ),\n)\n\nThis version of the constructor automatically creates ParticleStateful obejcts from the momenta, matching the particles of the process. In the case of our example process, this is means an incoming mock fermion and mock boson, and outgoing mock fermion and mock boson.\n\nAutomatic checks make sure that the number of 4-momenta given matches the necessary number of 4-momenta for the process (this adds 0 overhead at runtime because it is inferred from type information alone).\n\ntry # hide\n    PhaseSpacePoint(\n        MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n        MockModel(),\n        MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n        (rand(MockMomentum),), # incorrect number of incoming momenta, should be 2\n        (rand(MockMomentum), rand(MockMomentum)),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide\n\nAlternatively, a PhaseSpacePoint can also be constructed from already existing ParticleStateful objects.\n\npsp = PhaseSpacePoint(\n    MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n    MockModel(),\n    MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n    (   # incoming particles\n        ParticleStateful(Incoming(), MockFermion(), rand(MockMomentum)),\n        ParticleStateful(Incoming(), MockBoson(), rand(MockMomentum)),\n    ),\n    (   # outgoing particles\n        ParticleStateful(Outgoing(), MockFermion(), rand(MockMomentum)),\n        ParticleStateful(Outgoing(), MockBoson(), rand(MockMomentum)),\n    ),\n)\n\nSimilar to the constructor from momenta, this checks that the given ParticleStatefuls fit to the given process and throws otherwise. Again, since this can be infered from type information alone, it adds no overhead.\n\ntry # hide\n    PhaseSpacePoint(\n        MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n        MockModel(),\n        MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n        (   # incoming particles\n            ParticleStateful(Incoming(), MockBoson(), rand(MockMomentum)), # wrong particle type\n            ParticleStateful(Incoming(), MockBoson(), rand(MockMomentum)),\n        ),\n        (   # outgoing particles\n            ParticleStateful(Outgoing(), MockFermion(), rand(MockMomentum)),\n            ParticleStateful(Outgoing(), MockBoson(), rand(MockMomentum)),\n        ),\n    )\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide\n\nnote: Note\nWhile these constructors check that the given types make sense and work together, they do not check whether the given momenta make a physical phase space point or that the incoming or outgoing particles have on-shell 4-momenta.","category":"section"},{"location":"generated/particles/#Accessors","page":"Particles and Phase Space Points","title":"Accessors","text":"The phase space point provides some convenient accessors to the stateful particles within:\n\npsp[Incoming(), 1]  # the first incoming particle\n\npsp[Outgoing(), 2]  # the second outgoing particle\n\nparticles(psp, Incoming()) # all incoming particles as a tuple\n\nMomentum accessors:\n\nmomentum(psp, Incoming(), MockFermion(), 1) # the momentum of the first incoming electron\n\nWhen only one particle of the species exists in the particle set, the 1 can be omitted for convenience.\n\n@assert ans == momentum(psp, Incoming(), MockFermion())\n\nnote: Note\nThis method throws when multiple (or zero) particles of the given direction and species exist in the phase space point.\n\nWhen the index of the required momentum is known at compile time, a Val(N) can be used instead of N. This performs bounds checks at compile time and removes loops from the runtime execution\n\nusing BenchmarkTools\njudge(\n    median(@benchmark momentum($psp, Incoming(), MockBoson(), Val(1))),\n    median(@benchmark momentum($psp, Incoming(), MockBoson(), 1)),\n)\n\nnote: Note\nThis is only faster when N is actually known at compile time, for example when it is a literal integer or a function's type parameter. For dynamic values of N, prefer the Int variant or in case of loops, directly loop over the tuple of momenta.\n\nSome more overloads for the momentum function exist, for a complete list please refer to its documentation: QEDbase.momentum, QEDbase.momenta.\n\nFinally, process, model, and phase_space_layout can be used to request the object in question:\n\nprocess(psp)\n\nmodel(psp)\n\nphase_space_layout(psp)","category":"section"},{"location":"generated/particles/#In/Out-Phase-Space-Points","page":"Particles and Phase Space Points","title":"In/Out Phase Space Points","text":"As a special case, phase space points are allowed to only contain the incoming or outgoing particle momenta. These types can be helpful for overloading some functions that don't require the entire phase space point to exist.\n\nfunction in_sum(in_psp::AbstractInPhaseSpacePoint)\n    return sum(momenta(in_psp, Incoming()))\nend\n\npsp = InPhaseSpacePoint(\n    MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n    MockModel(),\n    MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n    (rand(MockMomentum), rand(MockMomentum)),\n)\n\nin_sum(psp)\n\nEvery full PhaseSpacePoint is both an InPhaseSpacePoint and an OutPhaseSpacePoint, too. For example, the in_sum function defined above still works with a full PhaseSpacePoint:\n\npsp = PhaseSpacePoint(\n    MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n    MockModel(),\n    MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n    (rand(MockMomentum), rand(MockMomentum)),\n    (rand(MockMomentum), rand(MockMomentum)),\n)\n\nin_sum(psp)\n\nBut an InPhaseSpacePoint is not an OutPhaseSpacePoint and vice versa. We cannot call in_sum on an OutPhaseSpacePoint:\n\npsp = OutPhaseSpacePoint(\n    MockProcess((MockFermion(), MockBoson()), (MockFermion(), MockBoson())),\n    MockModel(),\n    MockOutPhaseSpaceLayout(MockInPhaseSpaceLayout{MockMomentum}()),\n    (rand(MockMomentum), rand(MockMomentum)),\n)\n\ntry # hide\n    in_sum(psp)\n    throw(UnexpectedSuccess()) # hide\ncatch e # hide\n    if e isa UnexpectedSuccess # hide\n        rethrow(e) # hide\n    end # hide\n    @error e # hide\nend # hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"refs/#References","page":"References","title":"References","text":"P. J. Mohr, D. B. Newell, B. N. Taylor and E. Tiesinga. CODATA recommended values of the fundamental physical constants: 2022*. Rev. Mod. Phys. 97, 025002 (2025), arXiv:2409.03787 [hep-ph].\n\n\n\nR. Kleiss, W. J. Stirling and S. D. Ellis. A New Monte Carlo Treatment of Multiparticle Phase Space at High-energies. Comput. Phys. Commun. 40, 359 (1986).\n\n\n\n","category":"section"},{"location":"generated/constants/#Using-Physical-Constants-in-a-Type-Stable-Way","page":"Physical Constants","title":"Using Physical Constants in a Type-Stable Way","text":"This tutorial demonstrates how to work with physical constants defined using Base.@irrational in a type-preserving way, i.e., ensuring that calculations don't accidentally upcast to a different floating-point type due to the constant's default type.\n\nIn QEDcore.jl, the following constants are defined:\n\nALPHA\nALPHA_SQUARE\nELEMENTARY_CHARGE\nELEMENTARY_CHARGE_SQUARE\nELECTRONMASS\nONE_OVER_FOURPI\n\nThese constants are defined with the exact values given by [1], and they can be used with any floating-point type (Float64, Float32, Float16) without requiring runtime conversion.\n\nusing InteractiveUtils #hide\nusing QEDcore #hide","category":"section"},{"location":"generated/constants/#Converting-to-a-Different-Floating-Point-Type","page":"Physical Constants","title":"Converting to a Different Floating-Point Type","text":"You can explicitly convert a constant to a target type using a constructor, like:\n\nFloat32(ALPHA)\n\nor:\n\nFloat16(ELEMENTARY_CHARGE)\n\nThis works with any of the constants. The result is a value of the requested type, and the conversion occurs at compile time:\n\n@code_typed Float32(ALPHA)\n\nThis adds no runtime overhead.","category":"section"},{"location":"generated/constants/#Automatic-Conversion-during-Arithmetic-Operations","page":"Physical Constants","title":"Automatic Conversion during Arithmetic Operations","text":"For Base.AbstractIrrational types, arithmetic operations are defined such that the result adopts the type of the other operand. For example:\n\ntypeof(1.0 * ALPHA)\n\ntypeof(1.0f0 * ALPHA)\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"library/lorentzboosts/#Lorentz-Boosts","page":"Lorentz Boosts","title":"Lorentz Boosts","text":"The following is an implementation of the Lorentz Boost Interface of QEDbase.jl.","category":"section"},{"location":"library/lorentzboosts/#QEDcore.Boost","page":"Lorentz Boosts","title":"QEDcore.Boost","text":"Boost{V<:QEDbase.AbstractBoostParameter} <: QEDbase.AbstractLorentzBoost\n\nA concrete type representing a Lorentz boost transformation, parameterized by a boost parameter V. The boost parameter can be either axis-specific or vector-like, depending on the subtype of QEDbase.AbstractBoostParameter used. The Boost type is used to perform Lorentz boosts on four-vectors (such as four-momentum or four-position) between different inertial frames in special relativity.\n\nFields\n\nparam::V: A boost parameter of type V, which is a subtype of AbstractBoostParameter.   This parameter defines the velocity (as a fraction of the speed of light, beta)   and the direction of the boost (e.g., along a single axis or in multiple directions).\n\nOverview\n\nA Lorentz boost is a transformation that adjusts the time and spatial components of a four-vector based on the relative velocity between two reference frames. The Boost struct provides a general and flexible implementation of such a boost, where the type of the boost parameter determines the direction and magnitude of the boost.\n\nDepending on the boost parameter V, the boost can be:\n\nAxis-specific: When V is an axis-specific boost parameter (e.g., BetaX), the   boost will be along that axis.\nVector-like: When V is a vector of boost parameters (e.g., BetaVector), the   boost will have components in multiple spatial directions.\n\nExample\n\nTo create a Lorentz boost along the x-axis using the BetaX boost parameter:\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost_x = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\nTo perform a Lorentz boost using the boost_x object, you can apply it to a four-vector, such as four-momentum:\n\njulia> p = SFourMomentum(4, 3, 2, 1)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost_x(p)  # Perform the boost\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p, p_prime*p_prime)  # The invariant mass is preserved\n\nNotes\n\nThe Boost type provides a unified and flexible interface for applying Lorentz boosts, with the boost parameter V determining the specific form of the transformation. Lorentz boosts preserve the spacetime interval, meaning that applying the boost to a four-vector will not change the invariant quantity.\n\nSee Also\n\nQEDbase.AbstractBoostParameter: Base type for specific kinds of boost parameters.\nBetaX: Boost parameter for the x-axis.\nBetaY: Boost parameter for the y-axis.\nBetaZ: Boost parameter for the z-axis.\nBetaVector: Vector of boost parameters for boosts in multiple spatial directions.\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaVector","page":"Lorentz Boosts","title":"QEDcore.BetaVector","text":"BetaVector(x::Real,y::Real,z::Real)\n\nRepresents the spatial vector of velocity parameters (denoted as the \"beta\" vector) associated with motion in the three Cartesian directions, i.e., vecbeta = (beta_x beta_y beta_z). These components correspond to the velocity of an object (in units of the speed of light) in each of the x, y, and z directions.\n\nThe Lorentz boost along the direction of the beta vector vecbeta transforms the four-momentum as follows:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\n    gamma  (p_0 - vecbeta vec p)\np_1 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_x\np_2 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_y\n    p_3 + (fracgamma - 1beta^2 vecbetavec p - gamma  p_0)\n beta_z\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2.\n\nExample\n\njulia> using QEDcore\n\njulia> beta_vec = BetaVector(0.2,0.3,0.1)\nBetaVector{Float64}(0.2, 0.3, 0.1)\n\njulia> boost = Boost(beta_vec)\nBoost{BetaVector{Float64}}(BetaVector{Float64}(0.2, 0.3, 0.1))\n\njulia> p = SFourMomentum(4.0,3.0,2.0,1.0)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 2.911484876492837\n 2.282803602436349\n 0.9242054036545237\n 0.6414018012181746\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\nROOT::Math:Boost from ROOT\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaX","page":"Lorentz Boosts","title":"QEDcore.BetaX","text":"BetaX(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the x-axis, commonly denoted as beta_x.\n\nThe transformation for a boost along the x-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_x p_1)\ngamma (p_1 - beta_x p_0)\np_2\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_x^2)\n\nExample\n\njulia> using QEDcore\n\njulia> beta_x = BetaX(0.5)\nBetaX{Float64}(0.5)\n\njulia> boost = Boost(beta_x)\nBoost{BetaX{Float64}}(BetaX{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 2.886751345948129\n 1.1547005383792517\n 2.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaY","page":"Lorentz Boosts","title":"QEDcore.BetaY","text":"BetaY(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the y-axis, commonly denoted as beta_y.\n\nThe transformation for a boost along the y-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_y p_2)\np_1\ngamma (p_2 - beta_y p_0)\np_3\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_y^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_y = BetaY(0.5)\nBetaY{Float64}(0.5)\n\njulia> boost = Boost(beta_y)\nBoost{BetaY{Float64}}(BetaY{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 3.4641016151377553\n 3.0\n 0.0\n 1.0\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"library/lorentzboosts/#QEDcore.BetaZ","page":"Lorentz Boosts","title":"QEDcore.BetaZ","text":"BetaZ(beta::T) where {T<:Real}\n\nRepresents the beta parameter associated with a Lorentz boost along the z-axis, commonly denoted as beta_z.\n\nThe transformation for a boost along the z-axis is:\n\nbeginpmatrix\np_0\np_1\np_2\np_3\nendpmatrix mapsto\nbeginpmatrix\ngamma (p_0 - beta_z p_3)\np_1\np_2\ngamma (p_3 - beta_z p_0)\nendpmatrix\n\nwhere the kinematic factor is given as gamma = 1sqrt1-beta_z^2)\n\nExample\n\njulia> using QEDcore\n\njulia> using Random\n\njulia> RNG = MersenneTwister(1234)\nMersenneTwister(1234)\n\njulia> beta_z = BetaZ(0.5)\nBetaZ{Float64}(0.5)\n\njulia> boost = Boost(beta_z)\nBoost{BetaZ{Float64}}(BetaZ{Float64}(0.5))\n\njulia> p = SFourMomentum(4,3,2,1)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n 4.0\n 3.0\n 2.0\n 1.0\n\njulia> p_prime = boost(p)\n4-element SFourMomentum{Float64} with indices SOneTo(4):\n  4.041451884327381\n  3.0\n  2.0\n -1.1547005383792517\n\njulia> @assert isapprox(p*p,p_prime*p_prime) # Invariant mass is preserved\n\n\nExternal link\n\nLorentz Boost on Wikipedia\nKinematics in PDG review\n\n\n\n\n\n","category":"type"},{"location":"generated/vectors/#Vector-and-Matrix-Types","page":"Matrix and Vector Types","title":"Vector and Matrix Types","text":"TBW\n\nusing QEDcore","category":"section"},{"location":"generated/vectors/#Lorentz-Vectors","page":"Matrix and Vector Types","title":"Lorentz Vectors","text":"lv = rand(SLorentzVector)","category":"section"},{"location":"generated/vectors/#Bispinors-and-Adjoint-Bispinors","page":"Matrix and Vector Types","title":"Bispinors and Adjoint Bispinors","text":"bs = rand(BiSpinor)\n\nabs = rand(AdjointBiSpinor)\n\nabs * bs","category":"section"},{"location":"generated/vectors/#Dirac-and-Gamma-Matrices","page":"Matrix and Vector Types","title":"Dirac and Gamma Matrices","text":"gm = rand(DiracMatrix)\n\nabs * gm * bs\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"library/coordinates/#Coordinates","page":"Coordinates","title":"Coordinates","text":"","category":"section"},{"location":"library/coordinates/#Coordinate-Interface","page":"Coordinates","title":"Coordinate Interface","text":"","category":"section"},{"location":"library/coordinates/#Univariate-Coordinates","page":"Coordinates","title":"Univariate Coordinates","text":"","category":"section"},{"location":"library/coordinates/#Multivariate-Coordinates","page":"Coordinates","title":"Multivariate Coordinates","text":"","category":"section"},{"location":"library/coordinates/#QEDcore.AbstractCoordinateSet","page":"Coordinates","title":"QEDcore.AbstractCoordinateSet","text":"AbstractCoordinateSet{N}\n\nAn abstract type representing a set of coordinates with N elements.\n\nSubtypes of AbstractCoordinateSet used to define specific coordinate systems or layouts used to describe physical processes, such as phase-space parametrizations for scattering events. The parameter N specifies the number of coordinates in the set, where N can be one for univariate coordinates (e.g., energy, rapidity) or higher for more complex systems.\n\nType Parameters\n\nN: The number of coordinates in the set.\n\nIntended Usage\n\nSubtypes of AbstractCoordinateSet{N} implement the structure and behavior for specific coordinate systems. Functions like coordinate_names and coordinate_name are used to retrieve human-readable names for the coordinates in the set.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.coordinate_names","page":"Coordinates","title":"QEDcore.coordinate_names","text":"coordinate_names(coord_set::AbstractCoordinateSet)\n\nRetrieve the names of all coordinates in a given coordinate set.\n\nArguments\n\ncoord_set::AbstractCoordinateSet: A coordinate set, which is a container for multiple\n\ncoordinates.\n\nReturns\n\nA tuple of strings, where each string is the name of a coordinate in the set, including its particle index if available.\n\nThis function is typically implemented for subtypes of AbstractCoordinateSet and is used to return human-readable names for each coordinate in the set.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#QEDcore.coordinate_name","page":"Coordinates","title":"QEDcore.coordinate_name","text":"coordinate_name(coord::AbstractUnivariateCoordinate)\n\nRetrieve the name of a single univariate coordinate.\n\nArguments\n\ncoord::AbstractUnivariateCoordinate: A single univariate coordinate, which is a subtype of AbstractCoordinateSet{1} representing a coordinate system with one degree of freedom.\n\nReturns\n\nA string representing the name of the coordinate.\n\nThis function provides a human-readable label for a single coordinate and is generally used for naming individual coordinates in a scattering process or phase space.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#QEDcore.AbstractSingleParticleCoordinate","page":"Coordinates","title":"QEDcore.AbstractSingleParticleCoordinate","text":"AbstractSingleParticleCoordinate{IDX} <: AbstractUnivariateCoordinate\n\nAn abstract type representing a coordinate associated with a single particle. The type parameter IDX indicates the index of the particle in an AbstractProcessDefintion, either for the in- or out-channel, depending on the phase phase layout. Specific types that inherit from this abstract type define various coordinates (e.g., energy, rapidity, etc.) for the particle.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.particle_index","page":"Coordinates","title":"QEDcore.particle_index","text":"particle_index(coord::AbstractSingleParticleCoordinate{IDX})\n\nReturn the index of the particle the coord is related to, i.e. IDX.\n\n\n\n\n\n","category":"function"},{"location":"library/coordinates/#QEDcore.CenterOfMomentumEnergy","page":"Coordinates","title":"QEDcore.CenterOfMomentumEnergy","text":"CenterOfMomentumEnergy <: AbstractUnivariateCoordinate\n\nRepresents the center-of-momentum (CoM) energy coordinate in the definion of a phase space layout.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.Energy","page":"Coordinates","title":"QEDcore.Energy","text":"Energy{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the energy coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.SpatialMagnitude","page":"Coordinates","title":"QEDcore.SpatialMagnitude","text":"SpatialMagnitude{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the spatial spatial magnitude for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.Rapidity","page":"Coordinates","title":"QEDcore.Rapidity","text":"Rapidity{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the rapidity coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.CosTheta","page":"Coordinates","title":"QEDcore.CosTheta","text":"CosTheta{IDX} <: AbstractSingleParticleCoordinate{IDX}\n\nRepresents the cosine-theta coordinate for a single particle identified by IDX. This is mainly used for multiple dispatch and the definiton of phase space layouts.\n\n\n\n\n\n","category":"type"},{"location":"library/coordinates/#QEDcore.CoordinateSet","page":"Coordinates","title":"QEDcore.CoordinateSet","text":"CoordinateSet{N, D<:Tuple}\n\nA concrete type that represents a set of N coordinates, stored as a tuple coords::D. This type is a subtype of AbstractCoordinateSet{N} and is designed to handle sets of coordinates for use in various calculations, such as in phase space layouts.\n\nFields\n\ncoords::D: A tuple containing the individual coordinates. Each element of the tuple   corresponds to a coordinate in the set.\n\nConstructors\n\nCoordinateSet{N}(coords::D): Creates a CoordinateSet where the number of coordinates   N must match the length of the tuple coords. If they do not match,   an ArgumentError is thrown.\nCoordinateSet(coords::D): Automatically infers N as the length of the provided tuple   coords.\n\nThrows\n\nArgumentError if the length of the provided tuple does not match the specified   number N.\n\n\n\n\n\n","category":"type"},{"location":"library/constants/#Physical-Constants","page":"Constants","title":"Physical Constants","text":"","category":"section"},{"location":"library/constants/#QEDcore.ALPHA","page":"Constants","title":"QEDcore.ALPHA","text":"ALPHA\n\nThe fine-structure constant alpha approx 1137 (dimensionless), which characterizes the strength of electromagnetic interactions.\n\nThis value is defined using exactly the recommended value given in [1], but can be safely converted to any floating-point type (e.g., Float64(ALPHA) or one(Float32)*ALPHA) in a type-stable and compile-time safe manner.\n\n\n\n\n\n","category":"constant"},{"location":"library/constants/#QEDcore.ALPHA_SQUARE","page":"Constants","title":"QEDcore.ALPHA_SQUARE","text":"ALPHA_SQUARE\n\nThe square of the fine-structure constant, i.e. alpha^2. Useful in second-order electromagnetic processes.\n\nSupports type-stable conversion to all standard floating-point types.\n\n\n\n\n\n","category":"constant"},{"location":"library/constants/#QEDcore.ELEMENTARY_CHARGE","page":"Constants","title":"QEDcore.ELEMENTARY_CHARGE","text":"ELEMENTARY_CHARGE\n\nThe elementary charge e in natural units, defined as sqrt4pi alpha.\n\nDimensionless in natural units; useful in calculating Coulomb interactions or electromagnetic coupling factors.\n\nThis value is defined using exactly the recommended value given in [1], but can be safely converted to any floating-point type (e.g., Float64(ELEMENTARY_CHARGE) or one(Float32)*ELEMENTARY_CHARGE) in a type-stable and compile-time safe manner.\n\n\n\n\n\n","category":"constant"},{"location":"library/constants/#QEDcore.ELEMENTARY_CHARGE_SQUARE","page":"Constants","title":"QEDcore.ELEMENTARY_CHARGE_SQUARE","text":"ELEMENTARY_CHARGE_SQUARE\n\nThe square of the elementary charge in natural units: e^2.\n\nCommonly appears as a prefactor in scattering cross sections and Coulomb potentials.\n\n\n\n\n\n","category":"constant"},{"location":"library/constants/#QEDcore.ELECTRONMASS","page":"Constants","title":"QEDcore.ELECTRONMASS","text":"ELECTRONMASS\n\nElectron rest mass in electronvolts (eV), consistent with natural units.\n\nThis value is defined using exactly the recommended value given in [1], but can be safely converted to any floating-point type (e.g., Float64(ELECTRONMASS) or one(Float32)*ELECTRONMASS) in a type-stable and compile-time safe manner.\n\n\n\n\n\n","category":"constant"},{"location":"library/constants/#QEDcore.ONE_OVER_FOURPI","page":"Constants","title":"QEDcore.ONE_OVER_FOURPI","text":"ONE_OVER_FOURPI\n\nThe value 1  (4pi), often used as a Coulomb prefactor in Gaussian or natural unit systems.\n\nConvertible at compile time to all standard float types.\n\n\n\n\n\n","category":"constant"},{"location":"library/vectors/#Vector-and-Matrix-Types","page":"Vector Types","title":"Vector and Matrix Types","text":"","category":"section"},{"location":"library/vectors/#4-Momenta","page":"Vector Types","title":"4-Momenta","text":"","category":"section"},{"location":"library/vectors/#Spinors","page":"Vector Types","title":"Spinors","text":"","category":"section"},{"location":"library/vectors/#Lorentz-Vectors","page":"Vector Types","title":"Lorentz Vectors","text":"","category":"section"},{"location":"library/vectors/#Dirac-Matrix","page":"Vector Types","title":"Dirac Matrix","text":"","category":"section"},{"location":"library/vectors/#Multiplications","page":"Vector Types","title":"Multiplications","text":"","category":"section"},{"location":"library/vectors/#QEDcore.SFourMomentum","page":"Vector Types","title":"QEDcore.SFourMomentum","text":"struct SFourMomentum{T<:Real} <: AbstractFourMomentum{T<:Real}\n\nBuilds a static LorentzVectorLike with real components used to statically model the four-momentum of a particle or field.\n\nFields\n\nE::Real: energy component\npx::Real: x component\npy::Real: y component\npz::Real: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.BiSpinor","page":"Vector Types","title":"QEDcore.BiSpinor","text":"struct BiSpinor{T<:Number} <: AbstractDiracVector{T<:Number}\n\nConcrete type to model a Dirac four-spinor. These are the elements of an actual spinor space. By default, a constructed BiSpinor will have complex-valued components, using ComplexF64, but any other Number type can be used by explicitly calling BiSpinor{T}(el1, el2, el3, el4), which converts all given elements to T.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.AdjointBiSpinor","page":"Vector Types","title":"QEDcore.AdjointBiSpinor","text":"struct AdjointBiSpinor{T<:Number} <: AbstractDiracVector{T<:Number}\n\nConcrete type to model an adjoint Dirac four-spinor. These are the elements of the dual spinor space. By default, a constructed AdjointBiSpinor will have complex-valued components, using ComplexF64, but any other Number type can be used by explicitly calling AdjointBiSpinor{T}(el1, el2, el3, el4), which converts all given elements to T.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.SLorentzVector","page":"Vector Types","title":"QEDcore.SLorentzVector","text":"struct SLorentzVector{T} <: AbstractLorentzVector{T}\n\nConcrete implementation of a generic static Lorentz vector. Each manipulation of an concrete implementation which is not self-contained (i.e. produces the same Lorentz vector type) will result in this type.\n\nFields\n\nt::Any: t component\nx::Any: x component\ny::Any: y component\nz::Any: z component\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore.DiracMatrix","page":"Vector Types","title":"QEDcore.DiracMatrix","text":"struct DiracMatrix{T<:Number} <: AbstractDiracMatrix{T<:Number}\n\nConcrete type to model Dirac matrices, i.e. matrix representations of linear mappings between two spinor spaces.\n\n\n\n\n\n","category":"type"},{"location":"library/vectors/#QEDcore._mul","page":"Vector Types","title":"QEDcore._mul","text":"_mul(abs::AdjointBiSpinor, bs::BiSpinor) -> Any\n\n\nTensor product of an adjoint with a standard bi-spinor resulting in a scalar.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(bs::BiSpinor, abs::AdjointBiSpinor) -> DiracMatrix\n\n\nTensor product of a standard with an adjoint bi-spinor resulting in a Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(dm::DiracMatrix, bs::BiSpinor) -> Any\n\n\nTensor product of an Dirac matrix with a standard bi-spinor resulting in another standard bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(abs::AdjointBiSpinor, dm::DiracMatrix) -> Any\n\n\nTensor product of an adjoint bi-spinor with a Dirac matrix resulting in another adjoint bi-spinor.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(dm1::DiracMatrix, dm2::DiracMatrix) -> DiracMatrix\n\n\nTensor product two Dirac matrices resulting in another Dirac matrix.\n\nnote: Multiplication operator\nThis also overloads the * operator for this types.\n\n\n\n\n\n_mul(d::DiracMatrix, a::AdjointBiSpinor)\n\n\nThe product of a Dirac matrix with an adjoint bi-spinor from the right is not defined. Therefore, this throws a method error.\n\nnote: Note\nWe must throw this error explicitly, because otherwise the multiplication is dispatched to methods from StaticArrays.jl.\n\n\n\n\n\n_mul(b::BiSpinor, d::DiracMatrix)\n\n\nThe product of a Dirac matrix with a bi-spinor from the left is not defined. Therefore, this throws a method error.\n\nnote: Note\nWe must throw this error explicitly, because otherwise the multiplication is dispatched to methods from StaticArrays.jl.\n\n\n\n\n\n","category":"function"},{"location":"#QEDcore.jl","page":"Home","title":"QEDcore.jl","text":"(Image: Stable) (Image: Dev) (Image: code style: runic)\n\nThis package is part of the QuantumElectrodynamics.jl library. For the description of the interoperability with other packages of QuantumElectrodynamics.jl see docs.\n\nThis package's main purpose is to provide implementations of the basic interfaces defined in QEDbase.jl, such as various particle types, some concrete PhaseSpaceLayouts, PhaseSpacePoint, and various vector and matrix types. These types are used across most of the QEDjl-project repositories. For detailed information on these types, please refer to the respective pages in the docs.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Contributions are welcome! If you'd like to report a bug, suggest an enhancement, or contribute code, please feel free to open an issue or submit a pull request.\n\nTo ensure consistency across the QuantumElectrodynamics.jl ecosystem, we encourage all contributors to review the QuantumElectrodynamics.jl contribution guide.","category":"section"},{"location":"#Credits-and-contributors","page":"Home","title":"Credits and contributors","text":"This work was partly funded by the Center for Advanced Systems Understanding (CASUS) that is financed by Germany’s Federal Ministry of Education and Research (BMBF) and by the Saxon Ministry for Science, Culture and Tourism (SMWK) with tax funds on the basis of the budget approved by the Saxon State Parliament.\n\nThe core code of the package QEDcore.jl is developed by a small team at the Center for Advanced Systems Understanding (CASUS), namely","category":"section"},{"location":"#Core-Contributors","page":"Home","title":"Core Contributors","text":"Uwe Hernandez Acosta (CASUS/HZDR, u.hernandez@hzdr.de)\nAnton Reinhard (CASUS/HZDR)\nSimeon Ehrig (CASUS/HZDR)","category":"section"},{"location":"#Former-Contributors","page":"Home","title":"Former Contributors","text":"We extend our sincere thanks to all contributors who have supported this project.","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"We extend our gratitude for the support received through direct and indirect funding for this project, especially\n\nMichael Bussmann\nTobias Dornheim","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT © Uwe Hernandez Acosta","category":"section"}]
}
